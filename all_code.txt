package dataaccess;

import chess.ChessGame;
import model.GameData;
import model.UserData;
import org.junit.jupiter.api.*;

import java.util.List;

@TestMethodOrder(MethodOrderer.OrderAnnotation.class)
public class GameDAOTest {

    private static MySqlGameDAO gameDao;
    private static MySqlUserDAO userDao;

    @BeforeAll
    public static void init() {
        gameDao = new MySqlGameDAO();
        userDao = new MySqlUserDAO();
    }

    @BeforeEach
    public void setup() throws DataAccessException {
        // Clear both tables to have a clean state
        gameDao.clear();
        userDao.clear();

        // Insert users needed for foreign key constraints
        UserData user1 = new UserData("whitePlayer", "pass123", "white@example.com");
        UserData user2 = new UserData("blackPlayer", "pass456", "black@example.com");

        userDao.createUser(user1);
        userDao.createUser(user2);
    }

    @Test
    @Order(1)
    @DisplayName("Create game success")
    public void testCreateGameSuccess() throws DataAccessException {
        ChessGame chessGame = new ChessGame();
        GameData game = new GameData(0, "TestGame", "whitePlayer", "blackPlayer", chessGame);

        int id = gameDao.createGame(game);
        Assertions.assertTrue(id > 0, "Game ID should be positive");
    }

    @Test
    @Order(2)
    @DisplayName("Get game success")
    public void testGetGameSuccess() throws DataAccessException {
        ChessGame chessGame = new ChessGame();
        GameData game = new GameData(0, "TestGame", "whitePlayer", "blackPlayer", chessGame);

        int id = gameDao.createGame(game);
        GameData fetchedGame = gameDao.getGame(id);
        Assertions.assertNotNull(fetchedGame, "Fetched game should not be null");
        Assertions.assertEquals("TestGame", fetchedGame.gameName());
        Assertions.assertEquals("whitePlayer", fetchedGame.whiteUsername());
        Assertions.assertEquals("blackPlayer", fetchedGame.blackUsername());
    }


    @Test
    @Order(3)
    @DisplayName("Create game fails with invalid usernames (foreign key violation)")
    public void testCreateGameFailInvalidUsernames() {
        ChessGame chessGame = new ChessGame();
        // usernames that do NOT exist in users table
        GameData game = new GameData(0, "InvalidGame", "nonexistent1", "nonexistent2", chessGame);

        Assertions.assertThrows(DataAccessException.class, () -> {
            gameDao.createGame(game);
        });
    }

    @Test
    @Order(4)
    @DisplayName("Get game returns null for non-existent ID")
    public void testGetGameNotFound() throws DataAccessException {
        GameData game = gameDao.getGame(9999);  // assuming this ID does not exist
        Assertions.assertNull(game, "Game should be null if not found");
    }

    @Test
    @Order(5)
    @DisplayName("Update game success")
    public void testUpdateGameSuccess() throws DataAccessException {
        ChessGame chessGame = new ChessGame();
        GameData game = new GameData(0, "UpdateGame", "whitePlayer", "blackPlayer", chessGame);

        int id = gameDao.createGame(game);
        Assertions.assertTrue(id > 0);

        // Modify the game data
        GameData updatedGame = new GameData(id, "UpdatedName", "whitePlayer", "blackPlayer", chessGame);
        gameDao.updateGame(updatedGame);

        GameData fetched = gameDao.getGame(id);
        Assertions.assertNotNull(fetched);
        Assertions.assertEquals("UpdatedName", fetched.gameName());
    }

    @Test
    @Order(6)
    @DisplayName("Update game fails with invalid ID")
    public void testUpdateGameFailInvalidId() throws DataAccessException {
        ChessGame chessGame = new ChessGame();
        GameData game = new GameData(9999, "NoGame", "whitePlayer", "blackPlayer", chessGame);

        Assertions.assertDoesNotThrow(() -> {
            // The update may do nothing or throw - depends on implementation
            gameDao.updateGame(game);
        });
        // You could fetch and check that it wasn't created:
        Assertions.assertNull(gameDao.getGame(9999));
    }

    @Test
    @Order(7)
    @DisplayName("Get all games returns all inserted games")
    public void testGetAllGames() throws DataAccessException {
        ChessGame chessGame = new ChessGame();
        GameData game1 = new GameData(0, "Game1", "whitePlayer", "blackPlayer", chessGame);
        GameData game2 = new GameData(0, "Game2", "whitePlayer", "blackPlayer", chessGame);

        gameDao.createGame(game1);
        gameDao.createGame(game2);

        List<GameData> games = gameDao.getAllGames();
        Assertions.assertEquals(2, games.size());
    }

    @Test
    @Order(8)
    @DisplayName("Negative: get all games returns empty list when no games exist")
    public void testGetAllGamesEmpty() throws DataAccessException {
        // Make sure games table is empty
        gameDao.clear();

        List<GameData> games = gameDao.getAllGames();
        Assertions.assertNotNull(games);
        Assertions.assertTrue(games.isEmpty(), "Games list should be empty when no games exist");
    }

    @Test
    @Order(9)
    @DisplayName("Clear games deletes all entries")
    public void testClearGames() throws DataAccessException {
        ChessGame chessGame = new ChessGame();
        GameData game = new GameData(0, "GameToClear", "whitePlayer", "blackPlayer", chessGame);

        gameDao.createGame(game);
        gameDao.clear();

        List<GameData> games = gameDao.getAllGames();
        Assertions.assertTrue(games.isEmpty(), "Games table should be empty after clear");
    }
}
package dataaccess;

import model.AuthData;
import model.UserData;
import org.junit.jupiter.api.*;

import static org.junit.jupiter.api.Assertions.*;

@TestMethodOrder(MethodOrderer.OrderAnnotation.class)
public class AuthDAOTest {

    private static AuthDAO authDAO;
    private static UserDAO userDAO;

    @BeforeAll
    static void setup() throws DataAccessException {
        authDAO = new MySqlAuthDAO();
        userDAO = new MySqlUserDAO();

        userDAO.clear();
        userDAO.createUser(new UserData("user1", "password", "user1@example.com"));
        userDAO.createUser(new UserData("userDel", "password", "userdel@example.com"));
        userDAO.createUser(new UserData("userClear", "password", "userclear@example.com"));
    }

    @BeforeEach
    void clearAuth() throws DataAccessException {
        authDAO.clear();
    }

    // Helper methods
    private void createAuthToken(String token, String username) throws DataAccessException {
        authDAO.createAuth(new AuthData(token, username));
    }

    private void assertAuthDataEquals(AuthData authData, String expectedToken, String expectedUser) {
        assertNotNull(authData);
        assertEquals(expectedToken, authData.authToken());
        assertEquals(expectedUser, authData.username());
    }

    @Test
    @Order(1)
    @DisplayName("Positive: create and get auth token")
    void testCreateAndGetAuthSuccess() throws DataAccessException {
        createAuthToken("token123", "user1");
        AuthData fetched = authDAO.getAuth("token123");
        assertAuthDataEquals(fetched, "token123", "user1");
    }

    @Test
    @Order(2)
    @DisplayName("Negative: create auth with duplicate token throws exception")
    void testCreateAuthDuplicateTokenThrows() throws DataAccessException {
        createAuthToken("tokenDup", "user1");
        DataAccessException ex = assertThrows(DataAccessException.class, () -> {
            createAuthToken("tokenDup", "user1");
        });
        assertTrue(ex.getMessage().toLowerCase().contains("failed to create auth"));
    }

    @Test
    @Order(3)
    @DisplayName("Positive: get auth token returns valid AuthData")
    void testGetAuthSuccess() throws DataAccessException {
        createAuthToken("token123", "user1");
        AuthData fetched = authDAO.getAuth("token123");
        assertAuthDataEquals(fetched, "token123", "user1");
    }

    @Test
    @Order(4)
    @DisplayName("Negative: get auth token that doesn't exist returns null")
    void testGetAuthNotFound() throws DataAccessException {
        AuthData fetched = authDAO.getAuth("nonexistent");
        assertNull(fetched);
    }

    @Test
    @Order(5)
    @DisplayName("Positive: delete auth token")
    void testDeleteAuthSuccess() throws DataAccessException {
        createAuthToken("tokenToDelete", "userDel");
        authDAO.deleteAuth("tokenToDelete");
        AuthData fetched = authDAO.getAuth("tokenToDelete");
        assertNull(fetched);
    }

    @Test
    @Order(6)
    @DisplayName("Negative: delete auth token that doesn't exist does not throw")
    void testDeleteAuthNonExistent() {
        assertDoesNotThrow(() -> authDAO.deleteAuth("nonexistentToken"));
    }

    @Test
    @Order(7)
    @DisplayName("Positive: clear auth tokens")
    void testClearAuth() throws DataAccessException {
        createAuthToken("tokenClear", "userClear");
        authDAO.clear();
        AuthData fetched = authDAO.getAuth("tokenClear");
        assertNull(fetched);
    }
}
package dataaccess;

import model.UserData;
import org.junit.jupiter.api.*;

import static org.junit.jupiter.api.Assertions.*;

@TestMethodOrder(MethodOrderer.OrderAnnotation.class)
public class UserDAOTest {

    private static UserDAO userDAO;

    @BeforeAll
    static void setup() {
        userDAO = new MySqlUserDAO();
    }

    @BeforeEach
    void prepareDatabase() throws DataAccessException {
        userDAO.clear();
        // Create testUser for retrieval tests
        userDAO.createUser(new UserData("testUser", "pass123", "test@example.com"));
    }

    @Test
    @Order(1)
    @DisplayName("Positive: create user successfully")
    void testCreateUserSuccess() throws DataAccessException {
        // This user is already created in prepareDatabase,
        // so for uniqueness test create a different user here
        userDAO.createUser(new UserData("newUser", "newPass", "new@example.com"));
        // No exception means success
    }

    @Test
    @Order(2)
    @DisplayName("Positive: get existing user successfully")
    void testGetUserSuccess() throws DataAccessException {
        UserData fetched = userDAO.getUser("testUser");
        assertNotNull(fetched);
        assertEquals("testUser", fetched.username());
        assertEquals("pass123", fetched.password());
        assertEquals("test@example.com", fetched.email());
    }

    @Test
    @Order(3)
    @DisplayName("Negative: create user with duplicate username throws exception")
    void testCreateUserDuplicateThrows() throws DataAccessException {
        UserData duplicate = new UserData("testUser", "pass2", "dup@example.com");
        DataAccessException ex = assertThrows(DataAccessException.class, () -> {
            userDAO.createUser(duplicate);
        });
        assertTrue(ex.getMessage().toLowerCase().contains("failed to create user"));
    }

    @Test
    @Order(4)
    @DisplayName("Negative: get user that doesn't exist returns null")
    void testGetUserNotFound() throws DataAccessException {
        UserData fetched = userDAO.getUser("nonexistent");
        assertNull(fetched);
    }

    @Test
    @Order(5)
    @DisplayName("Positive: clear users removes all")
    void testClearUsers() throws DataAccessException {
        userDAO.clear();

        assertNull(userDAO.getUser("testUser"));
    }
}
package passoff.server;

import com.google.gson.GsonBuilder;

public class TestFactory {

    /*
     * Changing the return value will change how long tests will wait for the server to send messages.
     * The default for runtime is 3000 Milliseconds (3 seconds), and this will be enough for most computers.
     * Feel free to change this as you see fit, just know increasing it can make tests take longer to run.
     * (On the flip side, if you've got a good computer feel free to decrease it)
     *
     * WHILE DEBUGGING the websocket tests, the default runtime is 300000 Milliseconds (5 minutes).
     * If you feel like you would like more time to debug, you may increase the time as you please.
     *
     * If for some reason the tests seem to time out before reaching a point in the test you feel like they
     * should be, consider changing the last return value, instead of the default debug value.
     */
    public static Long getMessageTime() {
        boolean isDebug = java.lang.management.ManagementFactory.getRuntimeMXBean().getInputArguments()
                .toString().contains("jdwp");

        if (isDebug){
            return 300000L;
        }

        return 3000L;
    }

    public static GsonBuilder getGsonBuilder() {
        /*                  **NOT APPLICABLE TO MOST STUDENTS**
         * If you would like to change the way the web socket test cases serialize
         * or deserialize chess objects like ChessMove, you may add type adapters here.
         */
        GsonBuilder builder = new GsonBuilder();
        // builder.registerTypeAdapter(ChessMove.class, /*type adapter or json serializer */);
        return builder;
    }

}package passoff.server;

import chess.ChessGame;
import org.junit.jupiter.api.*;
import passoff.model.*;
import server.Server;

import java.lang.reflect.Method;
import java.sql.*;
import java.util.*;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.function.Supplier;

@TestMethodOrder(MethodOrderer.OrderAnnotation.class)
public class DatabaseTests {

    private static final TestUser TEST_USER = new TestUser("ExistingUser", "existingUserPassword", "eu@mail.com");

    private static TestServerFacade serverFacade;

    private static Server server;

    private static Class<?> databaseManagerClass;


    @BeforeAll
    public static void startServer() {
        server = new Server();
        var port = server.run(0);
        System.out.println("Started test HTTP server on " + port);

        serverFacade = new TestServerFacade("localhost", Integer.toString(port));
    }

    @BeforeEach
    public void setUp() {
        serverFacade.clear();
    }

    @AfterAll
    static void stopServer() {
        server.stop();
    }


    @Test
    @DisplayName("Persistence Test")
    @Order(1)
    public void persistenceTest() {
        int initialRowCount = getDatabaseRows();

        TestAuthResult regResult = serverFacade.register(TEST_USER);
        String auth = regResult.getAuthToken();

        //create a game
        String gameName = "Test Game";
        TestCreateResult createResult = serverFacade.createGame(new TestCreateRequest(gameName), auth);

        //join the game
        serverFacade.joinPlayer(new TestJoinRequest(ChessGame.TeamColor.WHITE, createResult.getGameID()), auth);

        Assertions.assertTrue(initialRowCount < getDatabaseRows(), "No new data added to database");

        // Test that we can read the data after a restart
        stopServer();
        startServer();

        //list games using the auth
        TestListResult listResult = serverFacade.listGames(auth);
        Assertions.assertEquals(200, serverFacade.getStatusCode(), "Server response code was not 200 OK");
        Assertions.assertEquals(1, listResult.getGames().length, "Missing game(s) in database after restart");

        TestListEntry game1 = listResult.getGames()[0];
        Assertions.assertEquals(game1.getGameID(), createResult.getGameID());
        Assertions.assertEquals(gameName, game1.getGameName(), "Game name changed after restart");
        Assertions.assertEquals(TEST_USER.getUsername(), game1.getWhiteUsername(),
                "White player username changed after restart");

        //test that we can still log in
        serverFacade.login(TEST_USER);
        Assertions.assertEquals(200, serverFacade.getStatusCode(), "Unable to login");
    }

    @Test
    @DisplayName("Bcrypt")
    @Order(2)
    public void bcrypt() {
        serverFacade.register(TEST_USER);
        Assertions.assertEquals(200, serverFacade.getStatusCode(), "Unable to register");
        executeForAllTables(this::checkTableForPassword);
    }

    @Test
    @DisplayName("Database Error Handling")
    @Order(3)
    public void databaseErrorHandling() throws ReflectiveOperationException {
        /*
        This test simulates an interruption in connecting to MySQL after the server is already running (it started with 
        MySQL working normally). If this happens, this should be considered an "Internal Server Error" and the response 
        code for any endpoint which no longer can do what it needs to do (which for this project should be all of them) 
        should be 500. The body of each of these responses should include a reasonable, relevant error message.
         */
        Properties fakeDbProperties = new Properties();
        fakeDbProperties.setProperty("db.name", UUID.randomUUID().toString());
        fakeDbProperties.setProperty("db.user", UUID.randomUUID().toString());
        fakeDbProperties.setProperty("db.password", UUID.randomUUID().toString());
        fakeDbProperties.setProperty("db.host", "localhost");
        fakeDbProperties.setProperty("db.port", "100000");

        Class<?> databaseManagerClass = findDatabaseManager();
        Method loadPropertiesMethod = databaseManagerClass.getDeclaredMethod("loadProperties", Properties.class);
        loadPropertiesMethod.setAccessible(true);
        Object obj = databaseManagerClass.getDeclaredConstructor().newInstance();
        loadPropertiesMethod.invoke(obj, fakeDbProperties);

        List<Supplier<TestResult>> operations = List.of(
                () -> serverFacade.clear(),
                () -> serverFacade.register(TEST_USER),
                () -> serverFacade.login(TEST_USER),
                () -> serverFacade.logout(UUID.randomUUID().toString()),
                () -> serverFacade.createGame(new TestCreateRequest("inaccessible"), UUID.randomUUID().toString()),
                () -> serverFacade.listGames(UUID.randomUUID().toString()),
                () -> serverFacade.joinPlayer(new TestJoinRequest(ChessGame.TeamColor.WHITE, 1), UUID.randomUUID().toString())
        );

        try {
            for (Supplier<TestResult> operation : operations) {
                TestResult result = operation.get();
                Assertions.assertEquals(500, serverFacade.getStatusCode(),
                        "Server response code was not 500 Internal Error");
                Assertions.assertNotNull(result.getMessage(), "Invalid Request didn't return an error message");
                Assertions.assertTrue(result.getMessage().toLowerCase(Locale.ROOT).contains("error"),
                        "Error message didn't contain the word \"Error\"");
            }
        } finally {
            Method loadFromResources = databaseManagerClass.getDeclaredMethod("loadPropertiesFromResources");
            loadFromResources.setAccessible(true);
            loadFromResources.invoke(obj);
        }
    }

    private int getDatabaseRows() {
        AtomicInteger rows = new AtomicInteger();
        executeForAllTables((tableName, connection) -> {
            try (var statement = connection.createStatement()) {
                var sql = "SELECT count(*) FROM " + tableName;
                try (var resultSet = statement.executeQuery(sql)) {
                    if (resultSet.next()) {
                        rows.addAndGet(resultSet.getInt(1));
                    }
                }
            }
        });

        return rows.get();
    }

    private void checkTableForPassword(String table, Connection connection) throws SQLException {
        String sql = "SELECT * FROM " + table;
        try (Statement statement = connection.createStatement(); ResultSet rs = statement.executeQuery(sql)) {
            ResultSetMetaData rsmd = rs.getMetaData();
            int columns = rsmd.getColumnCount();
            while (rs.next()) {
                for (int i = 1; i <= columns; i++) {
                    String value = rs.getString(i);
                    Assertions.assertFalse(value.contains(TEST_USER.getPassword()),
                            "Found clear text password in database");
                }
            }
        }
    }

    private void executeForAllTables(TableAction tableAction) {
        String sql = """
                    SELECT table_name
                    FROM information_schema.tables
                    WHERE table_schema = DATABASE();
                """;

        try (Connection conn = getConnection(); PreparedStatement preparedStatement = conn.prepareStatement(sql)) {
            try (var resultSet = preparedStatement.executeQuery()) {
                while (resultSet.next()) {
                    tableAction.execute(resultSet.getString(1), conn);
                }
            }
        } catch (ReflectiveOperationException | SQLException e) {
            Assertions.fail(e.getMessage(), e);
        }
    }

    private Connection getConnection() throws ReflectiveOperationException {
        Class<?> clazz = findDatabaseManager();
        Method getConnectionMethod = clazz.getDeclaredMethod("getConnection");
        getConnectionMethod.setAccessible(true);

        Object obj = clazz.getDeclaredConstructor().newInstance();
        return (Connection) getConnectionMethod.invoke(obj);
    }

    private Class<?> findDatabaseManager() throws ClassNotFoundException {
        if(databaseManagerClass != null) {
            return databaseManagerClass;
        }

        for (Package p : getClass().getClassLoader().getDefinedPackages()) {
            try {
                Class<?> clazz = Class.forName(p.getName() + ".DatabaseManager");
                clazz.getDeclaredMethod("getConnection");
                databaseManagerClass = clazz;
                return clazz;
            } catch (ReflectiveOperationException ignored) {}
        }
        throw new ClassNotFoundException("Unable to load database in order to verify persistence. " +
                "Are you using DatabaseManager to set your credentials? " +
                "Did you edit the signature of the getConnection method?");
    }

    @FunctionalInterface
    private interface TableAction {
        void execute(String tableName, Connection connection) throws SQLException;
    }

}
package passoff.server;

import chess.*;
import org.junit.jupiter.api.*;
import passoff.model.*;
import passoff.websocket.*;
import server.Server;
import websocket.commands.UserGameCommand;
import websocket.messages.ServerMessage;

import java.net.URISyntaxException;
import java.util.*;
import java.util.stream.Collectors;

import static websocket.messages.ServerMessage.ServerMessageType.*;

@TestMethodOrder(MethodOrderer.OrderAnnotation.class)
public class WebSocketTests {
    private static WebsocketTestingEnvironment environment;
    private static TestServerFacade serverFacade;
    private static Server server;
    private static Long waitTime;
    private WebsocketUser white;
    private WebsocketUser black;
    private WebsocketUser observer;
    private Integer gameID;

    @AfterAll
    static void stopServer() {
        server.stop();
    }

    @BeforeAll
    public static void init() throws URISyntaxException {
        server = new Server();
        var port = Integer.toString(server.run(0));
        System.out.println("Started test HTTP server on " + port);

        serverFacade = new TestServerFacade("localhost", port);
        serverFacade.clear();
        environment = new WebsocketTestingEnvironment("localhost", port, "/ws", TestFactory.getGsonBuilder());
        waitTime = TestFactory.getMessageTime();
    }

    @BeforeEach
    public void setup() {
        //populate database with HTTP calls
        serverFacade.clear();
        white = registerUser("white", "WHITE", "white@chess.com");
        black = registerUser("black", "BLACK", "black@chess.com");
        observer = registerUser("observer", "OBSERVER", "observer@chess.com");
        gameID = createGame(white, "testGame");
        joinGame(gameID, white, ChessGame.TeamColor.WHITE);
        joinGame(gameID, black, ChessGame.TeamColor.BLACK);
    }

    @AfterEach
    public void tearDown() {
        environment.disconnectAll();
    }

    @Test
    @Order(1)
    @DisplayName("Connect 1 User")
    public void connectSingleUser() {
        connectToGame(white, gameID, true, Set.of(), Set.of(), "white player connect");
    }

    @Test
    @Order(2)
    @DisplayName("Normal Connect")
    public void connectGood() {
        setupNormalGame();    //Connects 3 Users to the game, and notifies others upon connection
    }

    @Test
    @Order(3)
    @DisplayName("Connect Bad GameID")
    public void connectBadGameID() {
        connectToGame(white, gameID + 1, false, Set.of(), Set.of(), "player connect with wrong id");
        connectToGame(observer, gameID + 1, false, Set.of(white), Set.of(), "observer connect with wrong id");
    }

    @Test
    @Order(3)
    @DisplayName("Connect Bad AuthToken")
    public void connectBadAuthToken() {
        connectToGame(new WebsocketUser("didn't register", "badAuth"), gameID, false, Set.of(), Set.of(), "connect with bad auth");
    }

    @Test
    @Order(4)
    @DisplayName("Normal Make Move")
    public void validMove() {
        setupNormalGame();

        //make a valid pawn move
        ChessMove move = new ChessMove(new ChessPosition(2, 5), new ChessPosition(3, 5), null);
        makeMove(white, gameID, move,true, false, Set.of(black, observer), Set.of(), "move made");
    }

    @Test
    @Order(5)
    @DisplayName("Make Move Bad Authtoken")
    public void makeMoveBadAuthtoken() {
        setupNormalGame();

        //make valid move command with wrong authtoken
        ChessMove move = new ChessMove(new ChessPosition(2, 6), new ChessPosition(4, 6), null);
        makeMove(new WebsocketUser(white.username(), "badAuth"), gameID, move, false, false,
                Set.of(black, observer), Set.of(), "move made with bad authtoken");
    }

    @Test
    @Order(5)
    @DisplayName("Make Invalid Move")
    public void invalidMoveBadMove() {
        setupNormalGame();

        //try to move rook through a pawn - invalid move
        ChessMove move = new ChessMove(new ChessPosition(1, 1), new ChessPosition(1, 5), null);
        makeMove(white, gameID, move, false, false, Set.of(black, observer), Set.of(), "invalid move attempted");
    }

    @Test
    @Order(5)
    @DisplayName("Make Move Wrong Turn")
    public void invalidMoveWrongTurn() {
        setupNormalGame();

        //try to move pawn out of turn - would be valid if in turn
        ChessMove move = new ChessMove(new ChessPosition(7, 5), new ChessPosition(5, 5), null);
        makeMove(black, gameID, move, false, false, Set.of(white, observer), Set.of(), "move made out of turn");
    }

    @Test
    @Order(5)
    @DisplayName("Make Move for Opponent")
    public void invalidMoveOpponent() {
        setupNormalGame();

        //attempt to have black player move white piece
        ChessMove move = new ChessMove(new ChessPosition(2, 5), new ChessPosition(4, 5), null);
        makeMove(black, gameID, move, false, false, Set.of(white, observer), Set.of(), "move made for opponent");
    }

    @Test
    @Order(5)
    @DisplayName("Make Move Observer")
    public void invalidMoveObserver() {
        setupNormalGame();

        //have observer attempt to make an otherwise valid move
        ChessMove move = new ChessMove(new ChessPosition(2, 5), new ChessPosition(4, 5), null);
        makeMove(observer, gameID, move, false, false, Set.of(white, black), Set.of(), "observer attempts move");
    }

    @Test
    @Order(5)
    @DisplayName("Make Move Game Over")
    public void invalidMoveGameOver() {
        setupNormalGame();

        //Fools mate setup
        ChessMove move = new ChessMove(new ChessPosition(2, 7), new ChessPosition(4, 7), null);
        makeMove(white, gameID, move, true, false, Set.of(black, observer), Set.of(), "first move");
        move = new ChessMove(new ChessPosition(7, 5), new ChessPosition(6, 5), null);
        makeMove(black, gameID, move, true, false, Set.of(white, observer), Set.of(), "second move");
        move = new ChessMove(new ChessPosition(2, 6), new ChessPosition(3, 6), null);
        makeMove(white, gameID, move, true, false, Set.of(black, observer), Set.of(), "third move");
        move = new ChessMove(new ChessPosition(8, 4), new ChessPosition(4, 8), null);
        makeMove(black, gameID, move, true, true, Set.of(white, observer), Set.of(), "checkmate move");
        //checkmate--attempt another move
        move = new ChessMove(new ChessPosition(2, 5), new ChessPosition(4, 5), null);
        makeMove(white, gameID, move, false, false, Set.of(black, observer), Set.of(), "invalid move");
    }

    @Test
    @Order(6)
    @DisplayName("Normal Resign")
    public void validResign() {
        setupNormalGame();
        resign(white, gameID, true, Set.of(black, observer), Set.of(), "resign");
    }

    @Test
    @Order(7)
    @DisplayName("Cannot Move After Resign")
    public void moveAfterResign() {
        setupNormalGame();
        resign(black, gameID, true, Set.of(white, observer), Set.of(), "resign");

        //attempt to make a move after other player resigns
        ChessMove move = new ChessMove(new ChessPosition(2, 5), new ChessPosition(4, 5), null);
        makeMove(white, gameID, move, false, false, Set.of(black, observer), Set.of(), "move after resign");
    }

    @Test
    @Order(7)
    @DisplayName("Observer Resign")
    public void invalidResignObserver() {
        setupNormalGame();

        //have observer try to resign - should reject
        resign(observer, gameID, false, Set.of(white, black), Set.of(), "observer resign");
    }

    @Test
    @Order(7)
    @DisplayName("Double Resign")
    public void invalidResignGameOver() {
        setupNormalGame();
        resign(black, gameID, true, Set.of(white, observer), Set.of(), "first resign");

        //attempt to resign after other player resigns
        resign(white, gameID, false, Set.of(black, observer), Set.of(), "second resign");
    }

    @Test
    @Order(8)
    @DisplayName("Leave Game")
    public void leaveGame() {
        setupNormalGame();

        //have white player leave--all other players get notified, white player should not be
        leave(white, gameID, Set.of(black, observer), Set.of(), "player/first leave");

        //observer leaves - only black player should get a notification
        leave(observer, gameID, Set.of(black), Set.of(white), "observer/second leave");
    }

    @Test
    @Order(9)
    @DisplayName("Join After Leave Game")
    public void joinAfterLeaveGame() {
        setupNormalGame();

        //have white player leave--all other players get notified, white player should not be
        leave(white, gameID, Set.of(black, observer), Set.of(), "normal leave");

        //replace white player with a different player
        WebsocketUser white2 = registerUser("white2", "WHITE", "white2@chess.com");
        joinGame(gameID, white2, ChessGame.TeamColor.WHITE);
        connectToGame(white2, gameID, true, Set.of(black, observer), Set.of(white), "connect after leave");

        //new white player can make move
        ChessMove move = new ChessMove(new ChessPosition(2, 5), new ChessPosition(3, 5), null);
        makeMove(white2, gameID, move, true, false, Set.of(black, observer), Set.of(white), "new player moves");
    }

    @Test
    @Order(10)
    @DisplayName("Multiple Concurrent Games")
    public void multipleConcurrentGames() {
        setupNormalGame();

        //setup parallel game
        WebsocketUser white2 = registerUser("white2", "WHITE", "white2@chess.com");
        WebsocketUser black2 = registerUser("black2", "BLACK", "black2@chess.com");
        WebsocketUser observer2 = registerUser("observer2", "OBSERVER", "observer2@chess.com");
        int otherGameID = createGame(white, "testGame2");
        joinGame(otherGameID, white2, ChessGame.TeamColor.WHITE);
        joinGame(otherGameID, black2, ChessGame.TeamColor.BLACK);
        connectToGame(white2, otherGameID, true, Set.of(), Set.of(white, black, observer), "connect 1 to other game");
        connectToGame(black2, otherGameID, true, Set.of(white2), Set.of(white, black, observer), "connect 2 to other game");
        connectToGame(observer2, otherGameID, true,  Set.of(white2, black2), Set.of(white, black, observer), "connect 3 to other game");

        //make move in first game - only users in first game should be notified
        ChessMove move = new ChessMove(new ChessPosition(2, 5), new ChessPosition(3, 5), null);
        makeMove(white, gameID, move, true, false, Set.of(black, observer), Set.of(white2, black2, observer2), "move from game 1");

        //resign in second game - only users in second game should be notified
        resign(white2, otherGameID, true, Set.of(black2, observer2), Set.of(white, black, observer), "resign from game 2");

        //player leave in first game - only users remaining in first game should be notified
        leave(white, gameID, Set.of(black, observer), Set.of(white2, black2, observer2), "leave from game 1");
    }

    private void setupNormalGame() {
        connectToGame(white, gameID, true, Set.of(), Set.of(), "white player connect");
        connectToGame(black, gameID, true, Set.of(white), Set.of(), "black player connect");
        connectToGame(observer, gameID, true,  Set.of(white, black), Set.of(), "observer connect");
    }

    private WebsocketUser registerUser(String name, String password, String email) {
        TestAuthResult authResult = serverFacade.register(new TestUser(name, password, email));
        assertHttpOk(authResult, "registering a new user");
        return new WebsocketUser(authResult.getUsername(), authResult.getAuthToken());
    }

    private int createGame(WebsocketUser user, String name) {
        TestCreateResult createResult = serverFacade.createGame(new TestCreateRequest(name), user.authToken());
        assertHttpOk(createResult, "creating a new game");
        return createResult.getGameID();
    }

    private void joinGame(int gameID, WebsocketUser user, ChessGame.TeamColor color) {
        TestResult result = serverFacade.joinPlayer(new TestJoinRequest(color, gameID), user.authToken());
        assertHttpOk(result, "joining a player to a game");
    }

    private void assertHttpOk(TestResult result, String context) {
        Assertions.assertEquals(200, serverFacade.getStatusCode(),
                String.format("HTTP Status code was not 200 for %s, was %d. Message: %s",
                        context, serverFacade.getStatusCode(), result.getMessage()));
    }

    private void connectToGame(WebsocketUser sender, int gameID, boolean expectSuccess,
                               Set<WebsocketUser> inGame, Set<WebsocketUser> otherClients, String description) {
        TestCommand connectCommand = new TestCommand(UserGameCommand.CommandType.CONNECT, sender.authToken(), gameID);
        Map<String, Integer> numExpectedMessages = expectedMessages(sender, 1, inGame, (expectSuccess ? 1 : 0), otherClients);
        Map<String, List<TestMessage>> actualMessages = environment.exchange(sender.username(), connectCommand, numExpectedMessages, waitTime);

        assertCommandMessages(actualMessages, expectSuccess, sender, types(LOAD_GAME), inGame, types(NOTIFICATION), otherClients, description);
    }

    private void makeMove(WebsocketUser sender, int gameID, ChessMove move, boolean expectSuccess, boolean extraNotification,
                          Set<WebsocketUser> inGame, Set<WebsocketUser> otherClients, String description) {
        TestCommand moveCommand = new TestCommand(sender.authToken(), gameID, move);
        Map<String, Integer> numExpectedMessages = expectedMessages(sender, 1, inGame, (expectSuccess ? 2 : 0), otherClients);
        Map<String, List<TestMessage>> actualMessages = environment.exchange(sender.username(), moveCommand, numExpectedMessages, waitTime);

        if(extraNotification && actualMessages.get(sender.username()).size() > 1) {
            assertCommandMessages(actualMessages, expectSuccess, sender, types(LOAD_GAME, NOTIFICATION),
                    inGame, types(LOAD_GAME, NOTIFICATION, NOTIFICATION), otherClients, description);
        }
        else {
            assertCommandMessages(actualMessages, expectSuccess, sender, types(LOAD_GAME),
                    inGame, types(LOAD_GAME, NOTIFICATION), otherClients, description);
        }
    }

    private void resign(WebsocketUser sender, int gameID, boolean expectSuccess,
                        Set<WebsocketUser> inGame, Set<WebsocketUser> otherClients, String description) {
        TestCommand resignCommand = new TestCommand(UserGameCommand.CommandType.RESIGN, sender.authToken(), gameID);
        Map<String, Integer> numExpectedMessages = expectedMessages(sender, 1, inGame, (expectSuccess ? 1 : 0), otherClients);
        Map<String, List<TestMessage>> actualMessages = environment.exchange(sender.username(), resignCommand, numExpectedMessages, waitTime);

        assertCommandMessages(actualMessages, expectSuccess, sender, types(NOTIFICATION),
                inGame, types(NOTIFICATION), otherClients, description);
    }

    private void leave(WebsocketUser sender, int gameID, Set<WebsocketUser> inGame, Set<WebsocketUser> otherClients, String description) {
        TestCommand leaveCommand = new TestCommand(UserGameCommand.CommandType.LEAVE, sender.authToken(), gameID);
        Map<String, Integer> numExpectedMessages = expectedMessages(sender, 0, inGame, 1, otherClients);
        Map<String, List<TestMessage>> actualMessages = environment.exchange(sender.username(), leaveCommand, numExpectedMessages, waitTime);

        assertCommandMessages(actualMessages, true, sender, types(), inGame, types(NOTIFICATION), otherClients, description);
    }

    private Map<String, Integer> expectedMessages(WebsocketUser sender, int senderExpected,
                                                  Set<WebsocketUser> inGame, int inGameExpected, Set<WebsocketUser> otherClients) {
        Map<String, Integer> expectedMessages = new HashMap<>();
        expectedMessages.put(sender.username(), senderExpected);
        expectedMessages.putAll(inGame.stream().collect(Collectors.toMap(WebsocketUser::username, s -> inGameExpected)));
        expectedMessages.putAll(otherClients.stream().collect(Collectors.toMap(WebsocketUser::username, s -> 0)));
        return expectedMessages;
    }

    private void assertCommandMessages(Map<String, List<TestMessage>> messages, boolean expectSuccess,
                                       WebsocketUser user, ServerMessage.ServerMessageType[] userExpectedTypes,
                                       Set<WebsocketUser> inGame, ServerMessage.ServerMessageType[] inGameExpectedTypes,
                                       Set<WebsocketUser> otherClients, String description) {
        if(!expectSuccess) {
            userExpectedTypes = new ServerMessage.ServerMessageType[]{ERROR};
            inGameExpectedTypes = new ServerMessage.ServerMessageType[0];
        }
        assertMessages(user.username(), userExpectedTypes, messages.get(user.username()), description);
        for(WebsocketUser inGameUser : inGame) {
            assertMessages(inGameUser.username(), inGameExpectedTypes, messages.get(inGameUser.username()), description);
        }
        for(WebsocketUser otherUser : otherClients) {
            assertMessages(otherUser.username(), new ServerMessage.ServerMessageType[0], messages.get(otherUser.username()), description);
        }
    }

    private void assertMessages(String username, ServerMessage.ServerMessageType[] expectedTypes, List<TestMessage> messages, String description) {
        Assertions.assertEquals(expectedTypes.length, messages.size(), "For command '%s' user '%s' expected %d messages with types %s, got %d: %s"
                .formatted(description, username, expectedTypes.length, Arrays.toString(expectedTypes), messages.size(), messages));
        Arrays.sort(expectedTypes);
        messages.sort(Comparator.comparing(TestMessage::getServerMessageType));
        try {
            for(int i = 0; i < expectedTypes.length; i++) {
                switch (expectedTypes[i]) {
                    case LOAD_GAME -> assertLoadGame(username, messages.get(i));
                    case NOTIFICATION -> assertNotification(username, messages.get(i));
                    case ERROR -> assertError(username, messages.get(i));
                }
            }
        } catch(AssertionError e) {
            Assertions.fail("\nFor command '%s' user '%s' expected message types matching %s\nGot: %s\nCause: %s"
                    .formatted(description, username, Arrays.toString(expectedTypes), messages, e.getMessage()), e);
        }
    }

    private void assertLoadGame(String username, TestMessage message) {
        Assertions.assertEquals(ServerMessage.ServerMessageType.LOAD_GAME, message.getServerMessageType(),
                "Message for %s was not a LOAD_GAME message: %s".formatted(username, message));
        Assertions.assertNotNull(message.getGame(),
                "%s's LOAD_GAME message did not contain a game (Make sure it's specifically called 'game')".formatted(username));
        Assertions.assertNull(message.getMessage(),
                "%s's LOAD_GAME message contained a message: %s".formatted(username, message.getMessage()));
        Assertions.assertNull(message.getErrorMessage(),
                "%s's LOAD_GAME message contained an error message: %s".formatted(username, message.getErrorMessage()));
    }

    private void assertNotification(String username, TestMessage message) {
        Assertions.assertEquals(ServerMessage.ServerMessageType.NOTIFICATION, message.getServerMessageType(),
                "Message for %s was not a NOTIFICATION message: %s".formatted(username, message));
        Assertions.assertNotNull(message.getMessage(),
                "%s's NOTIFICATION message did not contain a message (Make sure it's specifically called 'message')".formatted(username));
        Assertions.assertNull(message.getGame(),
                "%s's NOTIFICATION message contained a game: %s".formatted(username, message.getGame()));
        Assertions.assertNull(message.getErrorMessage(),
                "%s's NOTIFICATION message contained an error message: %s".formatted(username, message.getErrorMessage()));
    }

    private void assertError(String username, TestMessage message) {
        Assertions.assertEquals(ServerMessage.ServerMessageType.ERROR, message.getServerMessageType(),
                "Message for %s was not an ERROR message: %s".formatted(username, message));
        Assertions.assertNotNull(message.getErrorMessage(),
                "%s's ERROR message did not contain an error message (Make sure it's specifically called 'errorMessage')".formatted(username));
        Assertions.assertNull(message.getGame(),
                "%s's ERROR message contained a game: %s".formatted(username, message.getGame()));
        Assertions.assertNull(message.getMessage(),
                "%s's ERROR message contained a non-error message: %s".formatted(username, message.getMessage()));
    }

    private ServerMessage.ServerMessageType[] types(ServerMessage.ServerMessageType... types) {
        return types;
    }

    private record WebsocketUser(String username, String authToken) { }
}package passoff.server;

import chess.ChessGame;
import org.junit.jupiter.api.*;
import passoff.model.*;
import server.Server;

import java.net.HttpURLConnection;
import java.util.*;

@TestMethodOrder(MethodOrderer.OrderAnnotation.class)
public class StandardAPITests {

    private static TestUser existingUser;
    private static TestUser newUser;
    private static TestCreateRequest createRequest;
    private static TestServerFacade serverFacade;
    private static Server server;
    private String existingAuth;

    // ### TESTING SETUP/CLEANUP ###

    @AfterAll
    static void stopServer() {
        server.stop();
    }

    @BeforeAll
    public static void init() {
        server = new Server();
        var port = server.run(0);
        System.out.println("Started test HTTP server on " + port);

        serverFacade = new TestServerFacade("localhost", Integer.toString(port));
        existingUser = new TestUser("ExistingUser", "existingUserPassword", "eu@mail.com");
        newUser = new TestUser("NewUser", "newUserPassword", "nu@mail.com");
        createRequest = new TestCreateRequest("testGame");
    }

    @BeforeEach
    public void setup() {
        serverFacade.clear();

        //one user already logged in
        TestAuthResult regResult = serverFacade.register(existingUser);
        existingAuth = regResult.getAuthToken();
    }

    // ### SERVER-LEVEL API TESTS ###

    @Test
    @Order(1)
    @DisplayName("Static Files")
    public void staticFilesSuccess() {
        String htmlFromServer = serverFacade.file("/").replaceAll("\r", "");
        Assertions.assertEquals(HttpURLConnection.HTTP_OK, serverFacade.getStatusCode(),
                "Server response code was not 200 OK");
        Assertions.assertNotNull(htmlFromServer, "Server returned an empty file");
        Assertions.assertTrue(htmlFromServer.contains("CS 240 Chess Server Web API"),
                "file returned did not contain an exact match of text from provided index.html");
    }

    @Test
    @Order(2)
    @DisplayName("Normal User Login")
    public void loginSuccess() {
        TestAuthResult loginResult = serverFacade.login(existingUser);

        assertHttpOk(loginResult);
        Assertions.assertEquals(existingUser.getUsername(), loginResult.getUsername(),
                "Response did not give the same username as user");
        Assertions.assertNotNull(loginResult.getAuthToken(), "Response did not return authentication String");
    }

    @Test
    @Order(3)
    @DisplayName("Login Bad Request")
    public void loginBadRequest() {
        TestUser[] incompleteLoginRequests = {
            new TestUser(null, existingUser.getPassword()),
            new TestUser(existingUser.getUsername(), null),
        };

        for (TestUser incompleteLoginRequest : incompleteLoginRequests) {
            TestAuthResult loginResult = serverFacade.login(incompleteLoginRequest);

            assertHttpBadRequest(loginResult);
            assertAuthFieldsMissing(loginResult);
        }
    }

    @Test
    @Order(3)
    @DisplayName("Login Unauthorized (Multiple Forms)")
    public void loginUnauthorized() {
        TestUser[] unauthorizedLoginRequests = { newUser, new TestUser(existingUser.getUsername(), "BAD!PASSWORD") };

        for (TestUser unauthorizedLoginRequest : unauthorizedLoginRequests) {
            TestAuthResult loginResult = serverFacade.login(unauthorizedLoginRequest);

            assertHttpUnauthorized(loginResult);
            assertAuthFieldsMissing(loginResult);
        }
    }

    @Test
    @Order(4)
    @DisplayName("Normal User Registration")
    public void registerSuccess() {
        //submit register request
        TestAuthResult registerResult = serverFacade.register(newUser);

        assertHttpOk(registerResult);
        Assertions.assertEquals(newUser.getUsername(), registerResult.getUsername(),
                "Response did not have the same username as was registered");
        Assertions.assertNotNull(registerResult.getAuthToken(), "Response did not contain an authentication string");
    }

    @Test
    @Order(5)
    @DisplayName("Re-Register User")
    public void registerTwice() {
        //submit register request trying to register existing user
        TestAuthResult registerResult = serverFacade.register(existingUser);

        assertHttpForbidden(registerResult);
        assertAuthFieldsMissing(registerResult);
    }

    @Test
    @Order(5)
    @DisplayName("Register Bad Request")
    public void registerBadRequest() {
        //attempt to register a user without a password
        TestUser registerRequest = new TestUser(newUser.getUsername(), null, newUser.getEmail());
        TestAuthResult registerResult = serverFacade.register(registerRequest);

        assertHttpBadRequest(registerResult);
        assertAuthFieldsMissing(registerResult);
    }

    @Test
    @Order(6)
    @DisplayName("Normal Logout")
    public void logoutSuccess() {
        //log out existing user
        TestResult result = serverFacade.logout(existingAuth);

        assertHttpOk(result);
    }

    @Test
    @Order(7)
    @DisplayName("Invalid Auth Logout")
    public void logoutTwice() {
        //log out user twice
        //second logout should fail
        serverFacade.logout(existingAuth);
        TestResult result = serverFacade.logout(existingAuth);

        assertHttpUnauthorized(result);
    }

    @Test
    @Order(8)
    @DisplayName("Valid Creation")
    public void createGameSuccess() {
        TestCreateResult createResult = serverFacade.createGame(createRequest, existingAuth);

        assertHttpOk(createResult);
        Assertions.assertNotNull(createResult.getGameID(), "Result did not return a game ID");
        Assertions.assertTrue(createResult.getGameID() > 0, "Result returned invalid game ID");
    }

    @Test
    @Order(9)
    @DisplayName("Create with Bad Authentication")
    public void createGameUnauthorized() {
        //log out user so auth is invalid
        serverFacade.logout(existingAuth);

        TestCreateResult createResult = serverFacade.createGame(createRequest, existingAuth);

        assertHttpUnauthorized(createResult);
        Assertions.assertNull(createResult.getGameID(), "Bad result returned a game ID");
    }

    @Test
    @Order(9)
    @DisplayName("Create Bad Request")
    public void createGameBadRequest() {
        TestCreateResult createResult = serverFacade.createGame(new TestCreateRequest(null), existingAuth);

        assertHttpBadRequest(createResult);
        Assertions.assertNull(createResult.getGameID(), "Bad result returned a game ID");
    }

    @Test
    @Order(10)
    @DisplayName("Join Created Game")
    public void joinGameSuccess() {
        //create game
        TestCreateResult createResult = serverFacade.createGame(createRequest, existingAuth);

        //join as white
        TestJoinRequest joinRequest = new TestJoinRequest(ChessGame.TeamColor.WHITE, createResult.getGameID());

        //try join
        TestResult joinResult = serverFacade.joinPlayer(joinRequest, existingAuth);

        //check
        assertHttpOk(joinResult);

        TestListResult listResult = serverFacade.listGames(existingAuth);

        Assertions.assertNotNull(listResult.getGames(), "List result did not contain games");
        Assertions.assertEquals(1, listResult.getGames().length, "List result is incorrect size");
        Assertions.assertEquals(existingUser.getUsername(), listResult.getGames()[0].getWhiteUsername(),
                "Username of joined player not present in list result");
        Assertions.assertNull(listResult.getGames()[0].getBlackUsername(), "Username present on non-joined color");
    }

    @Test
    @Order(11)
    @DisplayName("Join Bad Authentication")
    public void joinGameUnauthorized() {
        //create game
        TestCreateResult createResult = serverFacade.createGame(createRequest, existingAuth);

        //try join as white
        TestJoinRequest joinRequest = new TestJoinRequest(ChessGame.TeamColor.WHITE, createResult.getGameID());
        TestResult joinResult = serverFacade.joinPlayer(joinRequest, existingAuth + "bad stuff");

        //check
        assertHttpUnauthorized(joinResult);
    }

    @Test
    @Order(11)
    @DisplayName("Join Bad Team Color")
    public void joinGameBadColor() {
        TestCreateResult createResult = serverFacade.createGame(createRequest, existingAuth);
        int gameID = createResult.getGameID();

        //If you use deserialize to the TeamColor enum instead of a String each of these will be read as null
        for(String color : new String[]{null, "", "GREEN"}) {
            assertHttpBadRequest(serverFacade.joinPlayer(new TestJoinRequest(color, gameID), existingAuth));
        }
    }

    @Test
    @Order(11)
    @DisplayName("Join Steal Team Color")
    public void joinGameStealColor() {
        //create game
        TestCreateResult createResult = serverFacade.createGame(createRequest, existingAuth);

        //add existing user as black
        TestJoinRequest joinRequest = new TestJoinRequest(ChessGame.TeamColor.BLACK, createResult.getGameID());
        serverFacade.joinPlayer(joinRequest, existingAuth);

        //register second user
        TestAuthResult registerResult = serverFacade.register(newUser);

        //join request trying to also join  as black
        TestResult joinResult = serverFacade.joinPlayer(joinRequest, registerResult.getAuthToken());

        //check failed
        assertHttpForbidden(joinResult);
    }

    @Test
    @Order(11)
    @DisplayName("Join Bad Game ID")
    public void joinGameBadGameId() {
        //create game
        createRequest = new TestCreateRequest("Bad Join");
        serverFacade.createGame(createRequest, existingAuth);

        //try join as white
        TestJoinRequest joinRequest = new TestJoinRequest(ChessGame.TeamColor.WHITE, null);
        TestResult joinResult = serverFacade.joinPlayer(joinRequest, existingAuth);

        //check
        assertHttpBadRequest(joinResult);
    }

    @Test
    @Order(12)
    @DisplayName("List No Games")
    public void listGamesEmpty() {
        TestListResult result = serverFacade.listGames(existingAuth);

        assertHttpOk(result);
        Assertions.assertNotNull(result.getGames(), "List result did not contain an empty game list");
        Assertions.assertEquals(0, result.getGames().length, "Found games when none should be there");
    }

    @Test
    @Order(12)
    @DisplayName("List Multiple Games")
    public void listGamesSuccess() {
        //register a few users to create games
        TestUser userA = new TestUser("a", "A", "a.A");
        TestUser userB = new TestUser("b", "B", "b.B");
        TestUser userC = new TestUser("c", "C", "c.C");

        TestAuthResult authA = serverFacade.register(userA);
        TestAuthResult authB = serverFacade.register(userB);
        TestAuthResult authC = serverFacade.register(userC);

        //create games
        TestListEntry[] expectedList = new TestListEntry[4];

        //1 as black from A
        String game1Name = "I'm numbah one!";
        TestCreateResult game1 = serverFacade.createGame(new TestCreateRequest(game1Name), authA.getAuthToken());
        serverFacade.joinPlayer(new TestJoinRequest(ChessGame.TeamColor.BLACK, game1.getGameID()), authA.getAuthToken());
        expectedList[0] = new TestListEntry(game1.getGameID(), game1Name, null, authA.getUsername());


        //1 as white from B
        String game2Name = "Lonely";
        TestCreateResult game2 = serverFacade.createGame(new TestCreateRequest(game2Name), authB.getAuthToken());
        serverFacade.joinPlayer(new TestJoinRequest(ChessGame.TeamColor.WHITE, game2.getGameID()), authB.getAuthToken());
        expectedList[1] = new TestListEntry(game2.getGameID(), game2Name, authB.getUsername(), null);


        //1 of each from C
        String game3Name = "GG";
        TestCreateResult game3 = serverFacade.createGame(new TestCreateRequest(game3Name), authC.getAuthToken());
        serverFacade.joinPlayer(new TestJoinRequest(ChessGame.TeamColor.WHITE, game3.getGameID()), authC.getAuthToken());
        serverFacade.joinPlayer(new TestJoinRequest(ChessGame.TeamColor.BLACK, game3.getGameID()), authA.getAuthToken());
        expectedList[2] = new TestListEntry(game3.getGameID(), game3Name, authC.getUsername(), authA.getUsername());


        //C play self
        String game4Name = "All by myself";
        TestCreateResult game4 = serverFacade.createGame(new TestCreateRequest(game4Name), authC.getAuthToken());
        serverFacade.joinPlayer(new TestJoinRequest(ChessGame.TeamColor.WHITE, game4.getGameID()), authC.getAuthToken());
        serverFacade.joinPlayer(new TestJoinRequest(ChessGame.TeamColor.BLACK, game4.getGameID()), authC.getAuthToken());
        expectedList[3] = new TestListEntry(game4.getGameID(), game4Name, authC.getUsername(), authC.getUsername());


        //list games
        TestListResult listResult = serverFacade.listGames(existingAuth);
        assertHttpOk(listResult);
        TestListEntry[] returnedList = listResult.getGames();
        Assertions.assertNotNull(returnedList, "List result did not contain a list of games");
        Comparator<TestListEntry> gameIdComparator = Comparator.comparingInt(TestListEntry::getGameID);
        Arrays.sort(expectedList, gameIdComparator);
        Arrays.sort(returnedList, gameIdComparator);

        //check
        Assertions.assertArrayEquals(expectedList, returnedList, "Returned Games list was incorrect");
    }

    @Test
    @Order(13)
    @DisplayName("Unique Authtoken Each Login")
    public void uniqueAuthorizationTokens() {
        TestAuthResult loginOne = serverFacade.login(existingUser);
        assertHttpOk(loginOne);
        Assertions.assertNotNull(loginOne.getAuthToken(), "Login result did not contain an authToken");

        TestAuthResult loginTwo = serverFacade.login(existingUser);
        assertHttpOk(loginTwo);
        Assertions.assertNotNull(loginTwo.getAuthToken(), "Login result did not contain an authToken");

        Assertions.assertNotEquals(existingAuth, loginOne.getAuthToken(),
                "Authtoken returned by login matched authtoken from prior register");
        Assertions.assertNotEquals(existingAuth, loginTwo.getAuthToken(),
                "Authtoken returned by login matched authtoken from prior register");
        Assertions.assertNotEquals(loginOne.getAuthToken(), loginTwo.getAuthToken(),
                "Authtoken returned by login matched authtoken from prior login");


        TestCreateResult createResult = serverFacade.createGame(createRequest, existingAuth);
        assertHttpOk(createResult);


        TestResult logoutResult = serverFacade.logout(existingAuth);
        assertHttpOk(logoutResult);


        TestJoinRequest joinRequest = new TestJoinRequest(ChessGame.TeamColor.WHITE, createResult.getGameID());
        TestResult joinResult = serverFacade.joinPlayer(joinRequest, loginOne.getAuthToken());
        assertHttpOk(joinResult);


        TestListResult listResult = serverFacade.listGames(loginTwo.getAuthToken());
        assertHttpOk(listResult);
        Assertions.assertNotNull(listResult.getGames(), "List result did not contain games");
        Assertions.assertEquals(1, listResult.getGames().length, "List result contains incorrect number of games");
        Assertions.assertEquals(existingUser.getUsername(), listResult.getGames()[0].getWhiteUsername(),
                "incorrect username on joined game");
    }

    @Test
    @Order(14)
    @DisplayName("Clear Test")
    public void clearData() {
        //create filler games
        serverFacade.createGame(new TestCreateRequest("Mediocre game"), existingAuth);
        serverFacade.createGame(new TestCreateRequest("Awesome game"), existingAuth);

        //log in new user
        TestUser user = new TestUser("ClearMe", "cleared", "clear@mail.com");
        TestAuthResult registerResult = serverFacade.register(user);

        //create and join game for new user
        TestCreateResult createResult = serverFacade.createGame(new TestCreateRequest("Clear game"),
                registerResult.getAuthToken());

        TestJoinRequest joinRequest = new TestJoinRequest(ChessGame.TeamColor.WHITE, createResult.getGameID());
        serverFacade.joinPlayer(joinRequest, registerResult.getAuthToken());

        //do clear
        TestResult clearResult = serverFacade.clear();

        //test clear successful
        assertHttpOk(clearResult);

        //make sure neither user can log in
        //first user
        TestAuthResult loginResult = serverFacade.login(existingUser);
        assertHttpUnauthorized(loginResult);

        //second user
        loginResult = serverFacade.login(user);
        assertHttpUnauthorized(loginResult);

        //try to use old auth token to list games
        TestListResult listResult = serverFacade.listGames(existingAuth);
        assertHttpUnauthorized(listResult);

        //log in new user and check that list is empty
        registerResult = serverFacade.register(user);
        assertHttpOk(registerResult);
        listResult = serverFacade.listGames(registerResult.getAuthToken());
        assertHttpOk(listResult);

        //check listResult
        Assertions.assertNotNull(listResult.getGames(), "List result did not contain an empty list of games");
        Assertions.assertEquals(0, listResult.getGames().length, "list result did not return 0 games after clear");
    }

    @Test
    @Order(14)
    @DisplayName("Multiple Clears")
    public void clearMultipleTimes() {

        //clear multiple times
        serverFacade.clear();
        serverFacade.clear();
        TestResult result = serverFacade.clear();

        //make sure returned good
        assertHttpOk(result);
    }

    // ### HELPER ASSERTIONS ###

    private void assertHttpOk(TestResult result) {
        Assertions.assertEquals(HttpURLConnection.HTTP_OK, serverFacade.getStatusCode(),
                "Server response code was not 200 OK (message: %s)".formatted(result.getMessage()));
        Assertions.assertFalse(result.getMessage() != null &&
                        result.getMessage().toLowerCase(Locale.ROOT).contains("error"),
                "Result returned an error message");
    }

    private void assertHttpBadRequest(TestResult result) {
        assertHttpError(result, HttpURLConnection.HTTP_BAD_REQUEST, "Bad Request");
    }

    private void assertHttpUnauthorized(TestResult result) {
        assertHttpError(result, HttpURLConnection.HTTP_UNAUTHORIZED, "Unauthorized");
    }

    private void assertHttpForbidden(TestResult result) {
        assertHttpError(result, HttpURLConnection.HTTP_FORBIDDEN, "Forbidden");
    }

    private void assertHttpError(TestResult result, int statusCode, String message) {
        Assertions.assertEquals(statusCode, serverFacade.getStatusCode(),
                "Server response code was not %d %s (message: %s)".formatted(statusCode, message, result.getMessage()));
        Assertions.assertNotNull(result.getMessage(), "Invalid Request didn't return an error message");
        Assertions.assertTrue(result.getMessage().toLowerCase(Locale.ROOT).contains("error"),
                "Error message didn't contain the word \"Error\"");
    }

    private void assertAuthFieldsMissing(TestAuthResult result) {
        Assertions.assertNull(result.getUsername(), "Response incorrectly returned username");
        Assertions.assertNull(result.getAuthToken(), "Response incorrectly return authentication String");
    }

}
package service;

import handler.exceptions.ForbiddenException;
import model.AuthData;
import model.UserData;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import handler.exceptions.BadRequestException;
import handler.exceptions.UnauthorizedException;
import dataaccess.*;

import static org.junit.jupiter.api.Assertions.*;

public class LoginServiceTest {

    private LoginService service;
    private AuthDAO authDAO;
    private UserDAO userDAO;

    @BeforeEach
    public void setup() throws ForbiddenException, BadRequestException, DataAccessException {
        authDAO = new InMemoryAuth();
        userDAO = new InMemoryUser();
        new ClearService(authDAO, new InMemoryGame(), userDAO).clear();

        service = new LoginService(userDAO, authDAO);
        new RegisterService(userDAO, authDAO)
                .register(new UserData("tommy", "pass123", "tommy@email.com"));
    }

    @Test
    public void testLoginSuccess() throws UnauthorizedException, BadRequestException, DataAccessException, ForbiddenException {
        AuthData auth = service.login("tommy", "pass123");
        assertNotNull(auth);
        assertEquals("tommy", auth.username());
        assertNotNull(auth.authToken());
    }

    @Test
    public void testLoginWrongPassword() {
        assertThrows(UnauthorizedException.class, () -> service.login("tommy", "wrongpass"));
    }

    @Test
    public void testLoginNonexistentUser() {
        assertThrows(UnauthorizedException.class, () -> service.login("unknown", "pass"));
    }

    @Test
    public void testLoginMissingFields() {
        assertThrows(BadRequestException.class, () -> service.login(null, "pass123"));
        assertThrows(BadRequestException.class, () -> service.login("tommy", null));
    }
}
package service;

import dataaccess.*;
import handler.exceptions.BadRequestException;
import handler.exceptions.ForbiddenException;
import handler.exceptions.UnauthorizedException;
import model.AuthData;
import model.GameData;
import model.UserData;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;

import javax.xml.crypto.Data;

import static org.junit.jupiter.api.Assertions.*;

public class GameServiceTest {

    private AuthDAO authDAO;
    private UserDAO userDAO;
    private GameDAO gameDAO;

    private RegisterService registerService;
    private LoginService loginService;
    private GameService gameService;

    @BeforeEach
    void setup() {
        // Initialize in-memory DAOs
        authDAO = new InMemoryAuth();
        userDAO = new InMemoryUser();
        gameDAO = new InMemoryGame();

        // Initialize services
        registerService = new RegisterService(userDAO, authDAO);
        loginService = new LoginService(userDAO, authDAO);
        gameService = new GameService(authDAO, gameDAO, userDAO);
    }

    @Test
    void testCreateGameSuccess() throws ForbiddenException, BadRequestException, UnauthorizedException, DataAccessException {
        UserData user = new UserData("tommy", "pass123", "tommy@example.com");
        AuthData auth = registerService.register(user);

        int game = gameService.createGame(auth.authToken(), "My Chess Game");

        GameData stored = gameDAO.getGame(game);
        assertEquals(game, stored.gameID());
        assertNull(stored.whiteUsername());
        assertNull(stored.blackUsername());
    }

    @Test
    void testCreateGameUnauthorized() {
        assertThrows(UnauthorizedException.class, () ->
                gameService.createGame("invalidToken", "My Chess Game"));
    }

    @Test
    void testJoinGameSuccess() throws ForbiddenException, BadRequestException, UnauthorizedException, DataAccessException {
        UserData user = new UserData("tommy", "pass123", "tommy@example.com");
        AuthData auth = registerService.register(user);

        int game = gameService.createGame(auth.authToken(), "My Chess Game");

        gameService.joinGame(auth.authToken(), game, "WHITE");

        GameData updated = gameDAO.getGame(game);
        assertEquals("tommy", updated.whiteUsername());
        assertNull(updated.blackUsername());
    }

    @Test
    void testJoinGameInvalidColor() throws ForbiddenException, BadRequestException, UnauthorizedException, DataAccessException {
        UserData user = new UserData("tommy", "pass123", "tommy@example.com");
        AuthData auth = registerService.register(user);
        int game = gameService.createGame(auth.authToken(), "My Chess Game");

        assertThrows(BadRequestException.class, () ->
                gameService.joinGame(auth.authToken(), game, "PURPLE"));
    }

    @Test
    void testJoinGameInvalidToken() {
        assertThrows(UnauthorizedException.class, () ->
                gameService.joinGame("fakeToken", 1, "WHITE"));
    }
}
package service;

import model.AuthData;
import model.UserData;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import handler.exceptions.BadRequestException;
import handler.exceptions.ForbiddenException;
import dataaccess.*;

import static org.junit.jupiter.api.Assertions.*;

public class RegisterServiceTest {

    private RegisterService service;
    private UserDAO userDAO;
    private AuthDAO authDAO;

    @BeforeEach
    public void setup() throws DataAccessException {
        authDAO = new InMemoryAuth();
        userDAO = new InMemoryUser();
        new ClearService(authDAO, new InMemoryGame(), userDAO).clear();

        service = new RegisterService(userDAO, authDAO);
    }

    @Test
    public void testRegisterSuccess() throws ForbiddenException, BadRequestException, DataAccessException {
        UserData user = new UserData("tommy", "pass123", "tommy@email.com");
        AuthData auth = service.register(user);

        assertNotNull(auth);
        assertEquals("tommy", auth.username());
        assertNotNull(auth.authToken());
    }

    @Test
    public void testRegisterMissingField() {
        UserData user = new UserData("tommy", null, "tommy@email.com");
        assertThrows(BadRequestException.class, () -> service.register(user));
    }

    @Test
    public void testRegisterDuplicateUsername() throws ForbiddenException, BadRequestException, DataAccessException {
        UserData user = new UserData("tommy", "pass123", "tommy@email.com");
        service.register(user);

        UserData duplicate = new UserData("tommy", "pass456", "other@email.com");
        assertThrows(ForbiddenException.class, () -> service.register(duplicate));
    }
}
package service;

import handler.exceptions.BadRequestException;
import handler.exceptions.ForbiddenException;
import model.UserData;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import handler.exceptions.UnauthorizedException;
import dataaccess.*;

import static org.junit.jupiter.api.Assertions.*;

public class LogoutServiceTest {

    private LogoutService service;
    private AuthDAO authDAO;
    private UserDAO userDAO;
    private String token;

    @BeforeEach
    public void setup() throws ForbiddenException, BadRequestException, DataAccessException {
        authDAO = new InMemoryAuth();
        userDAO = new InMemoryUser();
        new ClearService(authDAO, new InMemoryGame(), userDAO).clear();

        service = new LogoutService(authDAO);

        token = new RegisterService(userDAO, authDAO)
                .register(new UserData("tommy", "pass123", "tommy@email.com"))
                .authToken();
    }

    @Test
    public void testLogoutSuccess() throws UnauthorizedException, DataAccessException {
        service.logout(token);
        assertThrows(UnauthorizedException.class, () -> service.logout(token));
    }

    @Test
    public void testLogoutInvalidToken() {
        assertThrows(UnauthorizedException.class, () -> service.logout("invalidtoken"));
    }
}
package handler;

import dataaccess.DataAccessException;
import io.javalin.http.Context;
import service.ClearService;

public class ClearHandler {

    private final ClearService service;

    public ClearHandler(ClearService service) {
        this.service = service;
    }

    public void clear(Context ctx) throws DataAccessException {
        service.clear();
        ctx.status(200);
    }
}
package handler;

public class Message {
    public String message;

    public Message(String message) { this.message = message; }
    public Message() {}
}
package handler;

import com.google.gson.Gson;
import handler.exceptions.BadRequestException;
import handler.exceptions.ForbiddenException;
import handler.exceptions.UnauthorizedException;
import io.javalin.Javalin;

public class ExceptionHandler {

    private final Gson gson = new Gson();

    public void register(Javalin app) {
        app.exception(Exception.class, (e, ctx) -> {
            ctx.result(gson.toJson(new Message("Error: " + e.getMessage())));
            ctx.status(getStatusCode(e));
        });
    }

    private int getStatusCode(Exception e) {
        return switch(e){
            case BadRequestException ignored -> 400;
            case UnauthorizedException ignored -> 401;
            case ForbiddenException ignored -> 403;
            default -> 500;
        };
    }
}
package handler;

import com.google.gson.Gson;
import dataaccess.DataAccessException;
import handler.exceptions.BadRequestException;
import handler.exceptions.UnauthorizedException;
import io.javalin.http.Context;
import model.AuthData;
import model.UserData;
import service.LoginService;

public class LoginHandler {

    private final Gson gson = new Gson();
    private final LoginService service;

    public LoginHandler(LoginService service) {
        this.service = service;
    }

    public void login(Context ctx) throws UnauthorizedException, BadRequestException, DataAccessException {
        UserData request = gson.fromJson(ctx.body(), UserData.class);
        AuthData auth = service.login(request.username(), request.password());
        ctx.status(200);
        ctx.result(gson.toJson(auth));
    }
}
package handler;

import com.google.gson.Gson;
import dataaccess.DataAccessException;
import handler.exceptions.ForbiddenException;
import handler.exceptions.UnauthorizedException;
import io.javalin.http.Context;
import model.GameData;
import service.GameService;
import handler.exceptions.BadRequestException;

import java.util.List;
import java.util.Map;

public class GameHandler {

    private final Gson gson = new Gson();
    private final GameService service;

    public GameHandler(GameService service) {
        this.service = service;
    }

    /** List all games for a user */
    public void listGames(Context ctx) throws BadRequestException, UnauthorizedException, DataAccessException {
        String authToken = ctx.header("authorization");
        if (authToken == null || authToken.isEmpty()) {
            throw new BadRequestException("Missing authorization header");
        }

        List<GameData> games = service.listGames(authToken);
        ctx.status(200);
        ctx.result(gson.toJson(Map.of("games", games)));
    }

    /** Create a new game */
    public void createGame(Context ctx) throws BadRequestException, UnauthorizedException, DataAccessException {
        String authToken = ctx.header("authorization");
        if (authToken == null || authToken.isEmpty()) {
            throw new BadRequestException("Missing authorization header");
        }

        Map<String, String> request;
        try {
            request = gson.fromJson(ctx.body(), Map.class);
        } catch (Exception e) {
            throw new BadRequestException("Invalid JSON body");
        }

        String gameName = request.get("gameName");
        if (gameName == null || gameName.isEmpty()) {
            throw new BadRequestException("gameName is required");
        }

        int gameID = service.createGame(authToken, gameName);

        ctx.status(200);
        ctx.result(gson.toJson(Map.of("gameID", gameID)));
    }

    /** Join an existing game as WHITE or BLACK */
    public void joinGame(Context ctx) throws BadRequestException, ForbiddenException, UnauthorizedException, DataAccessException {
        String authToken = ctx.header("authorization");
        if (authToken == null || authToken.isEmpty()) {
            throw new BadRequestException("Missing authorization header");
        }

        Map<String, Object> request;
        try {
            request = gson.fromJson(ctx.body(), Map.class);
        } catch (Exception e) {
            throw new BadRequestException("Invalid JSON body");
        }

        if (request.get("gameID") == null || request.get("playerColor") == null) {
            throw new BadRequestException("Missing gameID or playerColor");
        }

        int gameId;
        try {
            gameId = ((Number) request.get("gameID")).intValue();
        } catch (ClassCastException e) {
            throw new BadRequestException("gameID must be a number");
        }

        String playerColor = request.get("playerColor").toString();

        service.joinGame(authToken, gameId, playerColor);

        ctx.status(200);
    }
}
package handler.exceptions;

// 403 Forbidden / Already Taken
public class ForbiddenException extends Exception {
    public ForbiddenException(String message) { super(message); }
}package handler.exceptions;

// 401 Unauthorized
public class UnauthorizedException extends Exception {
    public UnauthorizedException(String message) { super(message); }
}package handler.exceptions;

// 400 Bad Request
public class BadRequestException extends Exception {
    public BadRequestException(String message) { super(message); }
}
package handler;

import dataaccess.DataAccessException;
import handler.exceptions.UnauthorizedException;
import io.javalin.http.Context;
import service.LogoutService;

public class LogoutHandler {

    private final LogoutService service;

    public LogoutHandler(LogoutService service) {
        this.service = service;
    }

    public void logout(Context ctx) throws UnauthorizedException, DataAccessException {
        String token = ctx.header("authorization");
        service.logout(token);
        ctx.status(200);
    }
}
package handler;

import com.google.gson.Gson;
import dataaccess.DataAccessException;
import handler.exceptions.BadRequestException;
import handler.exceptions.ForbiddenException;
import io.javalin.http.Context;
import model.AuthData;
import model.UserData;
import service.RegisterService;

public class RegisterHandler {

    private final Gson gson = new Gson();
    private final RegisterService service;

    public RegisterHandler(RegisterService service) {
        this.service = service;
    }

    public void register(Context ctx) throws ForbiddenException, BadRequestException, DataAccessException {
        UserData user = gson.fromJson(ctx.body(), UserData.class);
        AuthData auth = service.register(user);
        ctx.status(200);
        ctx.result(gson.toJson(auth));
    }
}
package server;

import com.google.gson.Gson;
import dataaccess.*;
import handler.*;
import service.*;

import io.javalin.Javalin;

public class Server {

    private Javalin app;

    // Run the server on the given port
    public int run(int port) {

        try {
            DatabaseManager.createDatabase();
            MySqlDatabaseInitializer.createTables();
        } catch (DataAccessException e) {
            System.err.println("Failed to initialize DB: " + e.getMessage());
            System.exit(1);
        }

        // Initialize DAOs
        AuthDAO authDAO = new MySqlAuthDAO();
        UserDAO userDAO = new MySqlUserDAO();
        GameDAO gameDAO = new MySqlGameDAO();

        // Initialize Services
        ClearService clearService = new ClearService(authDAO, gameDAO, userDAO);
        RegisterService registerService = new RegisterService(userDAO, authDAO);
        LoginService loginService = new LoginService(userDAO, authDAO);
        LogoutService logoutService = new LogoutService(authDAO);
        GameService gameService = new GameService(authDAO, gameDAO, userDAO);

        // Initialize Handlers
        ClearHandler clearHandler = new ClearHandler(clearService);
        RegisterHandler registerHandler = new RegisterHandler(registerService);
        LoginHandler loginHandler = new LoginHandler(loginService);
        LogoutHandler logoutHandler = new LogoutHandler(logoutService);
        GameHandler gameHandler = new GameHandler(gameService);
        ExceptionHandler exceptionHandler = new ExceptionHandler();

        // Create Javalin app
        app = Javalin.create(config -> config.staticFiles.add("web"));

        // Endpoints
        app.delete("/db", clearHandler::clear);
        app.post("/user", registerHandler::register);
        app.post("/session", loginHandler::login);
        app.delete("/session", logoutHandler::logout);
        app.get("/game", gameHandler::listGames);
        app.post("/game", gameHandler::createGame);
        app.put("/game", gameHandler::joinGame);

        // Register global exception handler
        exceptionHandler.register(app);

        System.out.println("Server running on http://localhost:" + port);

        app.start(port);

        return app.port();
    }

    // Stop the server
    public void stop() {
        if (app != null) {
            app.stop();
        }
    }


}
package dataaccess;

import java.sql.*;
import java.util.Properties;

public class DatabaseManager {
    private static String databaseName;
    private static String dbUsername;
    private static String dbPassword;
    private static String connectionUrl;

    /*
     * Load the database information for the db.properties file.
     */
    static {
        loadPropertiesFromResources();
    }

    /**
     * Creates the database if it does not already exist.
     */
    static public void createDatabase() throws DataAccessException {
        var statement = "CREATE DATABASE IF NOT EXISTS " + databaseName;
        try (var conn = DriverManager.getConnection(connectionUrl, dbUsername, dbPassword);
             var preparedStatement = conn.prepareStatement(statement)) {
            preparedStatement.executeUpdate();
        } catch (SQLException ex) {
            throw new DataAccessException("failed to create database", ex);
        }
    }

    /**
     * Create a connection to the database and sets the catalog based upon the
     * properties specified in db.properties. Connections to the database should
     * be short-lived, and you must close the connection when you are done with it.
     * The easiest way to do that is with a try-with-resource block.
     * <br/>
     * <code>
     * try (var conn = DatabaseManager.getConnection()) {
     * // execute SQL statements.
     * }
     * </code>
     */
    static Connection getConnection() throws DataAccessException {
        try {
            //do not wrap the following line with a try-with-resources
            var conn = DriverManager.getConnection(connectionUrl, dbUsername, dbPassword);
            conn.setCatalog(databaseName);
            return conn;
        } catch (SQLException ex) {
            throw new DataAccessException("failed to get connection", ex);
        }
    }

    private static void loadPropertiesFromResources() {
        try (var propStream = Thread.currentThread().getContextClassLoader().getResourceAsStream("db.properties")) {
            if (propStream == null) {
                throw new Exception("Unable to load db.properties");
            }
            Properties props = new Properties();
            props.load(propStream);
            loadProperties(props);
        } catch (Exception ex) {
            throw new RuntimeException("unable to process db.properties", ex);
        }
    }

    private static void loadProperties(Properties props) {
        databaseName = props.getProperty("db.name");
        dbUsername = props.getProperty("db.user");
        dbPassword = props.getProperty("db.password");

        var host = props.getProperty("db.host");
        var port = Integer.parseInt(props.getProperty("db.port"));
        connectionUrl = String.format("jdbc:mysql://%s:%d", host, port);
    }
}
package dataaccess;

import java.sql.Connection;
import java.sql.SQLException;
import java.sql.Statement;

public class MySqlDatabaseInitializer {

    public static void createTables() throws DataAccessException {
        try (Connection conn = DatabaseManager.getConnection();
             Statement stmt = conn.createStatement()) {

            String userTable = """
                CREATE TABLE IF NOT EXISTS users (
                    username VARCHAR(50) PRIMARY KEY,
                    password VARCHAR(60) NOT NULL,
                    email VARCHAR(100) NOT NULL
                );
                """;

            String authTable = """
                CREATE TABLE IF NOT EXISTS auth (
                    token VARCHAR(36) PRIMARY KEY,
                    username VARCHAR(50),
                    FOREIGN KEY (username) REFERENCES users(username) ON DELETE CASCADE
                );
                """;

            String gameTable = """
                CREATE TABLE IF NOT EXISTS games (
                    game_id INT PRIMARY KEY AUTO_INCREMENT,
                    game_name VARCHAR(100),
                    white_username VARCHAR(50),
                    black_username VARCHAR(50),
                    game_state TEXT,
                    FOREIGN KEY (white_username) REFERENCES users(username) ON DELETE SET NULL,
                    FOREIGN KEY (black_username) REFERENCES users(username) ON DELETE SET NULL
                );
                """;

            stmt.execute(userTable);
            stmt.execute(authTable);
            stmt.execute(gameTable);

        } catch (SQLException e) {
            throw new DataAccessException("Failed to create tables", e);
        }
    }
}
package dataaccess;

import model.AuthData;

public interface AuthDAO {

    void createAuth(AuthData auth) throws DataAccessException;
    AuthData getAuth(String token)throws DataAccessException;
    void deleteAuth(String token)throws DataAccessException;

    void clear() throws DataAccessException;
}
package dataaccess;

import model.UserData;

public interface UserDAO {
    void createUser(UserData user) throws DataAccessException;
    UserData getUser(String username) throws DataAccessException;
    void clear() throws DataAccessException;

}
package dataaccess;

import model.GameData;
import java.util.List;

public interface GameDAO {

    int createGame(GameData game) throws DataAccessException;
    GameData getGame(int gameId) throws DataAccessException;
    void updateGame(GameData game) throws DataAccessException;
    List<GameData> getAllGames() throws DataAccessException;

    void clear() throws DataAccessException;
}
package dataaccess;

import model.UserData;
import java.util.HashMap;
import java.util.Map;

/** In-memory implementation of UserDAO for testing */
public class InMemoryUser implements UserDAO {

    private final Map<String, UserData> users = new HashMap<>();

    @Override
    public void createUser(UserData user) {
        users.put(user.username(), user);
    }

    @Override
    public UserData getUser(String username) {
        return users.get(username);
    }

    @Override
    public void clear() {
        users.clear();
    }
}
package dataaccess;

import model.AuthData;
import java.util.HashMap;
import java.util.Map;

/** In-memory implementation of AuthDAO for testing */
public class InMemoryAuth implements AuthDAO {

    private final Map<String, AuthData> auths = new HashMap<>();

    @Override
    public void createAuth(AuthData auth) {
        auths.put(auth.authToken(), auth);
    }

    @Override
    public AuthData getAuth(String token) {
        return auths.get(token);
    }

    @Override
    public void deleteAuth(String token) {
        auths.remove(token);
    }

    @Override
    public void clear() {
        auths.clear();
    }
}
package dataaccess;

public class DataAccessException extends Exception {
    public DataAccessException(String message) { super(message); }
    public DataAccessException(String message, Throwable ex) { super(message, ex); }
}
package dataaccess;

import com.google.gson.Gson;
import model.GameData;
import chess.ChessGame;
import java.sql.*;
import java.util.ArrayList;
import java.util.List;

public class MySqlGameDAO implements GameDAO {

    private final Gson gson = new Gson();

    @Override
    public int createGame(GameData game) throws DataAccessException {
        String sql = "INSERT INTO games (game_name, white_username, black_username, game_state) VALUES (?, ?, ?, ?)";
        try (Connection conn = DatabaseManager.getConnection();
             PreparedStatement stmt = conn.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS)) {
            stmt.setString(1, game.gameName());
            stmt.setString(2, game.whiteUsername());
            stmt.setString(3, game.blackUsername());
            stmt.setString(4, gson.toJson(game.game()));
            stmt.executeUpdate();

            try (ResultSet keys = stmt.getGeneratedKeys()) {
                if (keys.next())  {
                    int id = keys.getInt(1);
                    return id;  // Add setter or create a new GameData with ID if immutable
                } else{
                    throw new DataAccessException("Game ID not found");
                }
            }
        } catch (SQLException e) {
            throw new DataAccessException("Failed to create game", e);
        }
    }

    @Override
    public GameData getGame(int gameId) throws DataAccessException {
        String sql = "SELECT * FROM games WHERE game_id = ?";
        try (Connection conn = DatabaseManager.getConnection();
             PreparedStatement stmt = conn.prepareStatement(sql)) {
            stmt.setInt(1, gameId);
            try (ResultSet rs = stmt.executeQuery()) {
                if (rs.next()) {
                    ChessGame chessGame = gson.fromJson(rs.getString("game_state"), ChessGame.class);
                    return new GameData(
                            rs.getInt("game_id"),
                            rs.getString("game_name"),
                            rs.getString("white_username"),
                            rs.getString("black_username"),
                            chessGame
                    );
                }
                return null;
            }
        } catch (SQLException e) {
            throw new DataAccessException("Failed to get game", e);
        }
    }

    @Override
    public void updateGame(GameData game) throws DataAccessException {
        String sql = "UPDATE games SET game_name = ?, white_username = ?, black_username = ?, game_state = ? WHERE game_id = ?";
        try (Connection conn = DatabaseManager.getConnection();
             PreparedStatement stmt = conn.prepareStatement(sql)) {
            stmt.setString(1, game.gameName());
            stmt.setString(2, game.whiteUsername());
            stmt.setString(3, game.blackUsername());
            stmt.setString(4, gson.toJson(game.game()));
            stmt.setInt(5, game.gameID());
            stmt.executeUpdate();
        } catch (SQLException e) {
            throw new DataAccessException("Failed to update game", e);
        }
    }


    @Override
    public List<GameData> getAllGames() throws DataAccessException {
        List<GameData> games = new ArrayList<>();
        String sql = "SELECT * FROM games";
        try (Connection conn = DatabaseManager.getConnection();
             PreparedStatement stmt = conn.prepareStatement(sql);
             ResultSet rs = stmt.executeQuery()) {
            while (rs.next()) {
                ChessGame chessGame = gson.fromJson(rs.getString("game_state"), ChessGame.class);
                games.add(new GameData(
                        rs.getInt("game_id"),
                        rs.getString("game_name"),
                        rs.getString("white_username"),
                        rs.getString("black_username"),
                        chessGame
                ));
            }
        } catch (SQLException e) {
            throw new DataAccessException("Failed to get all games", e);
        }
        return games;
    }

    @Override
    public void clear() throws DataAccessException {
        String sql = "DELETE FROM games";
        try (Connection conn = DatabaseManager.getConnection();
             PreparedStatement stmt = conn.prepareStatement(sql)) {
            stmt.executeUpdate();
        } catch (SQLException e) {
            throw new DataAccessException("Failed to clear games", e);
        }
    }
}
package dataaccess;

import model.UserData;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;

public class MySqlUserDAO implements UserDAO {

    @Override
    public void createUser(UserData user) throws DataAccessException {
        String sql = "INSERT INTO users (username, password, email) VALUES (?, ?, ?)";
        try (Connection conn = DatabaseManager.getConnection();
             PreparedStatement stmt = conn.prepareStatement(sql)) {
            stmt.setString(1, user.username());
            stmt.setString(2, user.password());
            stmt.setString(3, user.email());
            stmt.executeUpdate();
        } catch (SQLException e) {
            throw new DataAccessException("Failed to create user", e);
        }
    }

    @Override
    public UserData getUser(String username) throws DataAccessException {
        String sql = "SELECT * FROM users WHERE username = ?";
        try (Connection conn = DatabaseManager.getConnection();
             PreparedStatement stmt = conn.prepareStatement(sql)) {
            stmt.setString(1, username);
            try (ResultSet rs = stmt.executeQuery()) {
                if (rs.next()) {
                    return new UserData(
                            rs.getString("username"),
                            rs.getString("password"),
                            rs.getString("email")
                    );
                }
                return null;
            }
        } catch (SQLException e) {
            throw new DataAccessException("Failed to get user", e);
        }
    }

    @Override
    public void clear() throws DataAccessException {
        String sql = "DELETE FROM users";
        try (Connection conn = DatabaseManager.getConnection();
             PreparedStatement stmt = conn.prepareStatement(sql)) {
            stmt.executeUpdate();
        } catch (SQLException e) {
            throw new DataAccessException("Failed to clear users", e);
        }
    }
}
package dataaccess;

import model.AuthData;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;


public class MySqlAuthDAO implements AuthDAO {

    @Override
    public void createAuth(AuthData auth) throws DataAccessException {
        String sql = "INSERT INTO auth (token, username) VALUES (?, ?)";
        try (Connection conn = DatabaseManager.getConnection();
             PreparedStatement stmt = conn.prepareStatement(sql)) {
            stmt.setString(1, auth.authToken());
            stmt.setString(2, auth.username());
            stmt.executeUpdate();
        } catch (SQLException e) {
            throw new DataAccessException("Failed to create auth token", e);
        }
    }

    @Override
    public AuthData getAuth(String token) throws DataAccessException {
        String sql = "SELECT * FROM auth WHERE token = ?";
        try (Connection conn = DatabaseManager.getConnection();
             PreparedStatement stmt = conn.prepareStatement(sql)) {
            stmt.setString(1, token);
            try (ResultSet rs = stmt.executeQuery()) {
                if (rs.next()) {
                    return new AuthData(
                            rs.getString("token"),
                            rs.getString("username")
                    );
                }
                return null;
            }
        } catch (SQLException e) {
            throw new DataAccessException("Failed to get auth token", e);
        }
    }

    @Override
    public void deleteAuth(String token) throws DataAccessException {
        String sql = "DELETE FROM auth WHERE token = ?";
        try (Connection conn = DatabaseManager.getConnection();
             PreparedStatement stmt = conn.prepareStatement(sql)) {
            stmt.setString(1, token);
            stmt.executeUpdate();
        } catch (SQLException e) {
            throw new DataAccessException("Failed to delete auth token", e);
        }
    }

    @Override
    public void clear() throws DataAccessException {
        String sql = "DELETE FROM auth";
        try (Connection conn = DatabaseManager.getConnection();
             PreparedStatement stmt = conn.prepareStatement(sql)) {
            stmt.executeUpdate();
        } catch (SQLException e) {
            throw new DataAccessException("Failed to clear auth tokens", e);
        }
    }
}
package dataaccess;

import model.GameData;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/** In-memory implementation of GameDAO for testing */
public class InMemoryGame implements GameDAO {

    private final Map<Integer, GameData> games = new HashMap<>();
    private int nextGameId = 1;

    @Override
    public int createGame(GameData game) {
        games.put(game.gameID(), game);
        return nextGameId;
    }

    @Override
    public GameData getGame(int gameId) {
        return games.get(gameId);
    }

    @Override
    public void updateGame(GameData game) {
        games.put(game.gameID(), game);
    }

    @Override
    public List<GameData> getAllGames() {
        return new ArrayList<>(games.values());
    }

    @Override
    public void clear() {
        games.clear();
        nextGameId = 1;
    }
}
import server.Server;

public class Main {
    public static void main(String[] args) {
        Server server = new Server();
        server.run(8080);

        System.out.println(" 240 Chess Server");
    }
}package service;

import dataaccess.AuthDAO;
import dataaccess.DataAccessException;
import handler.exceptions.UnauthorizedException;

public class LogoutService {

    private final AuthDAO authDAO;

    public LogoutService(AuthDAO authDAO) {
        this.authDAO = authDAO;
    }

    public void logout(String token) throws UnauthorizedException, DataAccessException {
        if (token == null || authDAO.getAuth(token) == null) {
            throw new UnauthorizedException("unauthorized");
        }
        authDAO.deleteAuth(token);
    }
}
package service;

import dataaccess.AuthDAO;
import dataaccess.DataAccessException;
import dataaccess.UserDAO;
import handler.exceptions.BadRequestException;
import handler.exceptions.ForbiddenException;
import model.AuthData;
import model.UserData;
import org.mindrot.jbcrypt.BCrypt;

import java.util.UUID;

public class RegisterService {

    private final UserDAO userDAO;
    private final AuthDAO authDAO;

    public RegisterService(UserDAO userDAO, AuthDAO authDAO) {
        this.userDAO = userDAO;
        this.authDAO = authDAO;
    }

    public AuthData register(UserData user) throws ForbiddenException, BadRequestException, DataAccessException {
        if (user.username() == null || user.password() == null || user.email() == null) {
            throw new BadRequestException("bad request");
        }

        if (userDAO.getUser(user.username()) != null) {
            throw new ForbiddenException("already taken");
        }

        //hash password
        String hashedPassword = BCrypt.hashpw(user.password(), BCrypt.gensalt());
        UserData hashedUser = new UserData(user.username(), hashedPassword, user.email());
        userDAO.createUser(hashedUser);

        AuthData auth = new AuthData(UUID.randomUUID().toString(), user.username());
        authDAO.createAuth(auth);
        return auth;
    }
}
package service;

import dataaccess.DataAccessException;
import dataaccess.GameDAO;
import dataaccess.AuthDAO;
import dataaccess.UserDAO;

public class ClearService {

    private final AuthDAO authDAO;
    private final GameDAO gameDAO;
    private final UserDAO userDAO;

    // Constructor saves the DAOs to fields
    public ClearService(AuthDAO authDAO, GameDAO gameDAO, UserDAO userDAO){
        this.authDAO = authDAO;
        this.gameDAO = gameDAO;
        this.userDAO = userDAO;
    }

    public void clear() throws DataAccessException {
        userDAO.clear();
        gameDAO.clear();
        authDAO.clear();
    }
}package service;

import dataaccess.AuthDAO;
import dataaccess.DataAccessException;
import dataaccess.GameDAO;
import dataaccess.UserDAO;
import handler.exceptions.BadRequestException;
import handler.exceptions.ForbiddenException;
import handler.exceptions.UnauthorizedException;
import model.GameData;
import chess.ChessGame;

import java.util.List;

public class GameService {

    private final AuthDAO authDAO;
    private final GameDAO gameDAO;
    private final UserDAO userDAO;

    public GameService(AuthDAO authDAO, GameDAO gameDAO, UserDAO userDAO) {
        this.authDAO = authDAO;
        this.gameDAO = gameDAO;
        this.userDAO = userDAO;
    }

    /** Returns a list of all games, only if authToken is valid */
    public List<GameData> listGames(String authToken) throws UnauthorizedException, DataAccessException {
        var auth = authDAO.getAuth(authToken);
        if (auth == null) {
            throw new UnauthorizedException("unauthorized");
        }
        return gameDAO.getAllGames();
    }

    /** Creates a new game and returns it */
    public int createGame(String authToken, String gameName) throws BadRequestException, UnauthorizedException, DataAccessException {
        var auth = authDAO.getAuth(authToken);
        if (auth == null) {
            throw new UnauthorizedException("unauthorized");
        }
        if (gameName == null || gameName.isEmpty()) {
            throw new BadRequestException("bad request");
        }

        ChessGame chessGame = new ChessGame(); // initialize a new chess game
        GameData game = new GameData(1, gameName, null, null, chessGame);
        return gameDAO.createGame(game);
    }

    /** Joins a player to a game in the requested color */
    public void joinGame(
            String authToken,
            int gameId,
            String playerColor
    ) throws UnauthorizedException, BadRequestException, ForbiddenException, DataAccessException {
        var auth = authDAO.getAuth(authToken);
        if (auth == null) {
            throw new UnauthorizedException("unauthorized");
        }

        GameData game = gameDAO.getGame(gameId);
        if (game == null) {
            throw new BadRequestException("bad request");
        }

        if ("WHITE".equalsIgnoreCase(playerColor)) {
            if (game.whiteUsername() != null) {
                throw new ForbiddenException("already taken");
            }
            game = game.withWhite(auth.username());
        } else if ("BLACK".equalsIgnoreCase(playerColor)) {
            if (game.blackUsername() != null) {
                throw new ForbiddenException("already taken");
            }
            game = game.withBlack(auth.username());
        } else {
            throw new BadRequestException("bad request");
        }

        gameDAO.updateGame(game);
    }
}
package service;

import dataaccess.AuthDAO;
import dataaccess.DataAccessException;
import dataaccess.UserDAO;
import handler.exceptions.BadRequestException;
import handler.exceptions.UnauthorizedException;
import model.AuthData;
import model.UserData;
import org.mindrot.jbcrypt.BCrypt;

import java.util.UUID;

public class LoginService {

    private final UserDAO userDAO;
    private final AuthDAO authDAO;

    public LoginService(UserDAO userDAO, AuthDAO authDAO) {
        this.userDAO = userDAO;
        this.authDAO = authDAO;
    }

    public AuthData login(String username, String password) throws BadRequestException, UnauthorizedException, DataAccessException {
        if (username == null || password == null) {
            throw new BadRequestException("bad request");
        }
        UserData user = userDAO.getUser(username);
        if (user == null || !BCrypt.checkpw(password, user.password())) {
            throw new UnauthorizedException("unauthorized");
        }
        AuthData auth = new AuthData(UUID.randomUUID().toString(), username);
        authDAO.createAuth(auth);
        return auth;
    }
}
package passoff.chess;

import chess.ChessPosition;

import java.util.Collection;
import java.util.List;

public class ChessPositionTests extends EqualsTestingUtility<ChessPosition> {
    public ChessPositionTests() {
        super("ChessPosition", "positions");
    }

    @Override
    protected ChessPosition buildOriginal() {
        return new ChessPosition(3, 7);
    }

    @Override
    protected Collection<ChessPosition> buildAllDifferent() {
        return List.of(
                new ChessPosition(7, 3),
                new ChessPosition(6, 3),
                new ChessPosition(4, 3),
                new ChessPosition(3, 1),
                new ChessPosition(3, 2),
                new ChessPosition(3, 3)
        );
    }

}
package passoff.chess;

import chess.ChessBoard;
import chess.ChessGame;
import chess.ChessPiece;
import chess.ChessPosition;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

import java.util.ArrayList;
import java.util.Collection;
import java.util.List;

public class ChessBoardTests extends EqualsTestingUtility<ChessBoard> {
    public ChessBoardTests() {
        super("ChessBoard", "boards");
    }

    @Test
    @DisplayName("Construct Empty ChessBoard")
    public void constructChessBoard() {
        ChessBoard board = new ChessBoard();

        for (int row = 1; row <= 8; row++) {
            for (int col = 1; col <= 8; col++) {
                Assertions.assertNull(
                        board.getPiece(new ChessPosition(row, col)),
                        "Immediately upon construction, a ChessBoard should be empty."
                );
            }
        }

    }

    @Test
    @DisplayName("Add and Get Piece")
    public void getAddPiece() {
        ChessPosition position = new ChessPosition(4, 4);
        ChessPiece piece = new ChessPiece(ChessGame.TeamColor.BLACK, ChessPiece.PieceType.BISHOP);

        var board = new ChessBoard();
        board.addPiece(position, piece);

        ChessPiece foundPiece = board.getPiece(position);

        Assertions.assertNotNull(foundPiece, "getPiece returned null for a position just added");
        Assertions.assertEquals(piece.getPieceType(), foundPiece.getPieceType(),
                "ChessPiece returned by getPiece had the wrong piece type");
        Assertions.assertEquals(piece.getTeamColor(), foundPiece.getTeamColor(),
                "ChessPiece returned by getPiece had the wrong team color");
    }

    @Test
    @DisplayName("Reset Board")
    public void defaultGameBoard() {
        var expectedBoard = TestUtilities.defaultBoard();

        var actualBoard = new ChessBoard();
        actualBoard.resetBoard();

        Assertions.assertEquals(expectedBoard, actualBoard, "Reset board did not create the correct board");
    }

    @Override
    protected ChessBoard buildOriginal() {
        var basicBoard = new ChessBoard();
        basicBoard.resetBoard();
        return basicBoard;
    }

    @Override
    protected Collection<ChessBoard> buildAllDifferent() {
        List<ChessBoard> differentBoards = new ArrayList<>();

        differentBoards.add(new ChessBoard()); // An empty board

        ChessPiece.PieceType[] pieceSchedule = {
                ChessPiece.PieceType.ROOK, ChessPiece.PieceType.KNIGHT,
                ChessPiece.PieceType.BISHOP, ChessPiece.PieceType.QUEEN,
                ChessPiece.PieceType.KING, ChessPiece.PieceType.PAWN,
                ChessPiece.PieceType.KING, ChessPiece.PieceType.ROOK,
        };

        // Generate boards each with one piece added from a static list.
        // The color is assigned in a mixed pattern.
        ChessPiece.PieceType type;
        boolean isWhite;
        for (int col = 1; col <= 8; col++) {
            for (int row = 1; row <= 8; row++) {
                type = pieceSchedule[row-1];
                isWhite = (row + col) % 2 == 0;
                differentBoards.add(createBoardWithPiece(row, col, type, isWhite));
            }
        }

        return differentBoards;
    }

    private ChessBoard createBoardWithPiece(int row, int col, ChessPiece.PieceType type, boolean isWhite) {
        var board = new ChessBoard();

        var teamColor = isWhite ? ChessGame.TeamColor.WHITE : ChessGame.TeamColor.BLACK;
        var piece = new ChessPiece(teamColor, type);

        var position = new ChessPosition(row, col);
        board.addPiece(position, piece);

        return board;
    }

}
package passoff.chess.game;

import chess.ChessGame;
import chess.ChessMove;
import chess.ChessPosition;
import chess.InvalidMoveException;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

public class FullGameTest {
    @Test
    @DisplayName("Full Game Checkmate")
    public void scholarsMate() throws InvalidMoveException {
        var game = new ChessGame();
        game.makeMove(new ChessMove(new ChessPosition(2, 5), new ChessPosition(4, 5), null));
        /*
                |r|n|b|q|k|b|n|r|
                |p|p|p|p|p|p|p|p|
                | | | | | | | | |
                | | | | | | | | |
                | | | | |P| | | |
                | | | | | | | | |
                |P|P|P|P| |P|P|P|
                |R|N|B|Q|K|B|N|R|
         */
        game.makeMove(new ChessMove(new ChessPosition(7, 5), new ChessPosition(5, 5), null));
        /*
                |r|n|b|q|k|b|n|r|
                |p|p|p|p| |p|p|p|
                | | | | | | | | |
                | | | | |p| | | |
                | | | | |P| | | |
                | | | | | | | | |
                |P|P|P|P| |P|P|P|
                |R|N|B|Q|K|B|N|R|
         */
        game.makeMove(new ChessMove(new ChessPosition(1, 6), new ChessPosition(4, 3), null));
        /*
                |r|n|b|q|k|b|n|r|
                |p|p|p|p| |p|p|p|
                | | | | | | | | |
                | | | | |p| | | |
                | | |B| |P| | | |
                | | | | | | | | |
                |P|P|P|P| |P|P|P|
                |R|N|B|Q|K| |N|R|
         */
        game.makeMove(new ChessMove(new ChessPosition(8, 7), new ChessPosition(6, 6), null));
        /*
                |r|n|b|q|k|b| |r|
                |p|p|p|p| |p|p|p|
                | | | | | |n| | |
                | | | | |p| | | |
                | | |B| |P| | | |
                | | | | | | | | |
                |P|P|P|P| |P|P|P|
                |R|N|B|Q|K| |N|R|
         */
        game.makeMove(new ChessMove(new ChessPosition(1, 4), new ChessPosition(5, 8), null));
        /*
                |r|n|b|q|k|b| |r|
                |p|p|p|p| |p|p|p|
                | | | | | |n| | |
                | | | | |p| | |Q|
                | | |B| |P| | | |
                | | | | | | | | |
                |P|P|P|P| |P|P|P|
                |R|N|B| |K| |N|R|
         */
        game.makeMove(new ChessMove(new ChessPosition(8, 2), new ChessPosition(6, 3), null));
        /*
                |r| |b|q|k|b| |r|
                |p|p|p|p| |p|p|p|
                | | |n| | |n| | |
                | | | | |p| | |Q|
                | | |B| |P| | | |
                | | | | | | | | |
                |P|P|P|P| |P|P|P|
                |R|N|B| |K| |N|R|
         */
        game.makeMove(new ChessMove(new ChessPosition(5, 8), new ChessPosition(7, 6), null));
        /*
                |r| |b|q|k|b| |r|
                |p|p|p|p| |Q|p|p|
                | | |n| | |n| | |
                | | | | |p| | | |
                | | |B| |P| | | |
                | | | | | | | | |
                |P|P|P|P| |P|P|P|
                |R|N|B| |K| |N|R|
         */
        Assertions.assertTrue(game.isInCheck(ChessGame.TeamColor.BLACK), GameStatusTests.MISSING_BLACK_CHECK);
        Assertions.assertFalse(game.isInCheck(ChessGame.TeamColor.WHITE), GameStatusTests.INCORRECT_WHITE_CHECK);
        Assertions.assertTrue(game.isInCheckmate(ChessGame.TeamColor.BLACK), GameStatusTests.MISSING_BLACK_CHECKMATE);
        Assertions.assertFalse(game.isInCheckmate(ChessGame.TeamColor.WHITE), GameStatusTests.INCORRECT_WHITE_CHECKMATE);
        Assertions.assertFalse(game.isInStalemate(ChessGame.TeamColor.BLACK), GameStatusTests.INCORRECT_BLACK_STALEMATE);
        Assertions.assertFalse(game.isInStalemate(ChessGame.TeamColor.WHITE), GameStatusTests.INCORRECT_WHITE_STALEMATE);
    }
}
package passoff.chess.game;

import chess.ChessGame;
import chess.ChessMove;
import chess.ChessPosition;
import chess.InvalidMoveException;
import passoff.chess.EqualsTestingUtility;
import passoff.chess.TestUtilities;

import java.util.ArrayList;
import java.util.Collection;

public class ChessGameTests extends EqualsTestingUtility<ChessGame> {
    public ChessGameTests() {
        super("ChessGame", "games");
    }

    @Override
    protected ChessGame buildOriginal() {
        return new ChessGame();
    }

    @Override
    protected Collection<ChessGame> buildAllDifferent() {
        Collection<ChessGame> differentGames = new ArrayList<>();

        try {
            // Different team turn
            ChessGame game1 = new ChessGame();
            game1.setTeamTurn(ChessGame.TeamColor.BLACK);
            differentGames.add(game1);

            // Move pawn
            ChessGame game2 = new ChessGame();
            game2.makeMove(new ChessMove(
                    new ChessPosition(2, 5),
                    new ChessPosition(4, 5),
                    null));
            differentGames.add(game2);

            // Move knight
            ChessGame game3 = new ChessGame();
            game3.makeMove(new ChessMove(
                    new ChessPosition(1, 7),
                    new ChessPosition(3, 6),
                    null));
            differentGames.add(game3);

            // Set board
            ChessGame game4 = new ChessGame();
            game4.setBoard(TestUtilities.loadBoard("""
                    | | | |R| | | | |
                    | | | | | | | | |
                    | | |p|n|p| | | |
                    |R| |n|k|r| | |R|
                    | | |p|q| | | | |
                    | | | | | |K| | |
                    | | | | |P| | | |
                    | | | |R| | | | |
                    """));
            differentGames.add(game4);

        } catch (InvalidMoveException e) {
            throw new RuntimeException("All moves in ChessGameTests are valid and should be allowed.", e);
        }

        return differentGames;
    }
}
package passoff.chess.game;

import chess.*;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.EnumSource;
import passoff.chess.TestUtilities;

public class MakeMoveTests {
    private static final String WRONG_BOARD = "Board not correct after move made";
    private ChessGame game;

    @BeforeEach
    public void setUp() {
        game = new ChessGame();
        game.setTeamTurn(ChessGame.TeamColor.WHITE);
        game.setBoard(TestUtilities.defaultBoard());
    }

    @Test
    @DisplayName("Make Valid King Move")
    public void makeValidKingMove() throws InvalidMoveException {
        game.setBoard(TestUtilities.loadBoard("""
                | | | | | | | | |
                |p| | | | | | |k|
                | | | | | | | | |
                | | | | | | | | |
                | | | | | | | | |
                | | | | | | | | |
                | | | | | | | | |
                | |K| | | | | | |
                """));
        game.setTeamTurn(ChessGame.TeamColor.WHITE);

        var kingStartPosition = new ChessPosition(1, 2);
        var kingEndPosition = new ChessPosition(1, 1);
        game.makeMove(new ChessMove(kingStartPosition, kingEndPosition, null));

        Assertions.assertEquals(TestUtilities.loadBoard("""
                | | | | | | | | |
                |p| | | | | | |k|
                | | | | | | | | |
                | | | | | | | | |
                | | | | | | | | |
                | | | | | | | | |
                | | | | | | | | |
                |K| | | | | | | |
                """), game.getBoard(), WRONG_BOARD);
    }

    @Test
    @DisplayName("Make Valid Queen Move")
    public void makeValidQueenMove() throws InvalidMoveException {
        game.setBoard(TestUtilities.loadBoard("""
                | | | | | | | | |
                | | | | | | | | |
                | | | | | | |q| |
                | | | | | | | | |
                | | | | | | | | |
                | | | | | | | | |
                | | | | | | | | |
                |K| |k| | | | | |
                """));
        game.setTeamTurn(ChessGame.TeamColor.BLACK);

        var queenStartPosition = new ChessPosition(6, 7);
        var queenEndPosition = new ChessPosition(1, 2);
        game.makeMove(new ChessMove(queenStartPosition, queenEndPosition, null));

        Assertions.assertEquals(TestUtilities.loadBoard("""
                | | | | | | | | |
                | | | | | | | | |
                | | | | | | | | |
                | | | | | | | | |
                | | | | | | | | |
                | | | | | | | | |
                | | | | | | | | |
                |K|q|k| | | | | |
                """), game.getBoard(), WRONG_BOARD);
    }

    @Test
    @DisplayName("Make Valid Rook Move")
    public void makeValidRookMove() throws InvalidMoveException {
        game.setBoard(TestUtilities.loadBoard("""
                | | | | |k| | | |
                | | | | | | | | |
                | | | | | | | | |
                | | | | | | | | |
                | | | | | | | | |
                | | | | | | | |R|
                | | | | | | | | |
                |K| | | | | | | |
                """));
        game.setTeamTurn(ChessGame.TeamColor.WHITE);

        var rookStartPosition = new ChessPosition(3, 8);
        var rookEndPosition = new ChessPosition(7, 8);
        game.makeMove(new ChessMove(rookStartPosition, rookEndPosition, null));

        Assertions.assertEquals(TestUtilities.loadBoard("""
                | | | | |k| | | |
                | | | | | | | |R|
                | | | | | | | | |
                | | | | | | | | |
                | | | | | | | | |
                | | | | | | | | |
                | | | | | | | | |
                |K| | | | | | | |
                """), game.getBoard(), WRONG_BOARD);
    }

    @Test
    @DisplayName("Make Valid Knight Move")
    public void makeValidKnightMove() throws InvalidMoveException {
        game.setBoard(TestUtilities.loadBoard("""
                | | | | |k| | | |
                | | | | | | | | |
                | | |n| | | | | |
                | | | | | | | | |
                | | | | | | | | |
                | | | | | | | | |
                | | | | | | | |P|
                | | | | |K| | | |
                """));
        game.setTeamTurn(ChessGame.TeamColor.BLACK);

        var knightStartPosition = new ChessPosition(6, 3);
        var knightEndPosition = new ChessPosition(4, 4);
        game.makeMove(new ChessMove(knightStartPosition, knightEndPosition, null));

        Assertions.assertEquals(TestUtilities.loadBoard("""
                | | | | |k| | | |
                | | | | | | | | |
                | | | | | | | | |
                | | | | | | | | |
                | | | |n| | | | |
                | | | | | | | | |
                | | | | | | | |P|
                | | | | |K| | | |
                """), game.getBoard(), WRONG_BOARD);
    }

    @Test
    @DisplayName("Make Valid Bishop Move")
    public void makeValidBishopMove() throws InvalidMoveException {
        game.setBoard(TestUtilities.loadBoard("""
                | | | | |k| | | |
                |p| | | | | | | |
                | | | | | | | | |
                | | | | | | | | |
                | | | | | | | | |
                | | | | | | | | |
                | | | | | | | | |
                | | |B| |K| | | |
                """));
        game.setTeamTurn(ChessGame.TeamColor.WHITE);

        var bishopStartPosition = new ChessPosition(1, 3);
        var bishopEndPosition = new ChessPosition(6, 8);
        game.makeMove(new ChessMove(bishopStartPosition, bishopEndPosition, null));

        Assertions.assertEquals(TestUtilities.loadBoard("""
                | | | | |k| | | |
                |p| | | | | | | |
                | | | | | | | |B|
                | | | | | | | | |
                | | | | | | | | |
                | | | | | | | | |
                | | | | | | | | |
                | | | | |K| | | |
                """), game.getBoard(), WRONG_BOARD);
    }

    @Test
    @DisplayName("Make Valid Pawn Move")
    public void makeValidPawnMove() throws InvalidMoveException {
        game.setBoard(TestUtilities.loadBoard("""
                | |k| | | | | | |
                | |p| | | | | | |
                | | | | | | | | |
                | | | | | | | | |
                | | | | | | | | |
                | | | | | | | | |
                | | | | | | |P| |
                | | | | | | |K| |
                """));
        game.setTeamTurn(ChessGame.TeamColor.BLACK);

        var pawnStartPosition = new ChessPosition(7, 2);
        var pawnEndPosition = new ChessPosition(6, 2);
        game.makeMove(new ChessMove(pawnStartPosition, pawnEndPosition, null));

        Assertions.assertEquals(TestUtilities.loadBoard("""
                | |k| | | | | | |
                | | | | | | | | |
                | |p| | | | | | |
                | | | | | | | | |
                | | | | | | | | |
                | | | | | | | | |
                | | | | | | |P| |
                | | | | | | |K| |
                """), game.getBoard(), WRONG_BOARD);
    }

    @Test
    @DisplayName("Make Move Changes Team Turn")
    public void makeMoveChangesTurn() throws InvalidMoveException {
        String failureMessage = "Team color not changed after move made";

        game.makeMove(new ChessMove(new ChessPosition(2, 5), new ChessPosition(4, 5), null));
        Assertions.assertEquals(ChessGame.TeamColor.BLACK, game.getTeamTurn(), failureMessage);

        game.makeMove(new ChessMove(new ChessPosition(7, 5), new ChessPosition(5, 5), null));
        Assertions.assertEquals(ChessGame.TeamColor.WHITE, game.getTeamTurn(), failureMessage);
    }

    @Test
    @DisplayName("Invalid Make Move Too Far")
    public void invalidMakeMoveTooFar() {
        Assertions.assertThrows(InvalidMoveException.class,
                () -> game.makeMove(new ChessMove(new ChessPosition(2, 1), new ChessPosition(5, 1), null)));
    }

    @Test
    @DisplayName("Invalid Make Move Pawn Diagonal No Capture")
    public void invalidMakeMovePawnDiagonalNoCapture() {
        Assertions.assertThrows(InvalidMoveException.class,
                () -> game.makeMove(new ChessMove(new ChessPosition(2, 1), new ChessPosition(3, 2), null)));
    }

    @Test
    @DisplayName("Invalid Make Move Out Of Turn")
    public void invalidMakeMoveOutOfTurn() {
        Assertions.assertThrows(InvalidMoveException.class,
                () -> game.makeMove(new ChessMove(new ChessPosition(7, 5), new ChessPosition(6, 5), null)));
    }

    @Test
    @DisplayName("Invalid Make Move Through Piece")
    public void invalidMakeMoveThroughPiece() {
        Assertions.assertThrows(InvalidMoveException.class,
                () -> game.makeMove(new ChessMove(new ChessPosition(1, 1), new ChessPosition(4, 1), null)));
    }

    @Test
    @DisplayName("Invalid Make Move No Piece")
    public void invalidMakeMoveNoPiece() {
        //starting position does not have a piece
        Assertions.assertThrows(InvalidMoveException.class,
                () -> game.makeMove(new ChessMove(new ChessPosition(4, 4), new ChessPosition(4, 5), null)));
    }

    @Test
    @DisplayName("Invalid Make Move Invalid Move")
    public void invalidMakeMoveInvalidMove() {
        //not a move the piece can ever take
        Assertions.assertThrows(InvalidMoveException.class,
                () -> game.makeMove(new ChessMove(new ChessPosition(8, 7), new ChessPosition(5, 5), null)));
    }

    @Test
    @DisplayName("Invalid Make Move Take Own Piece")
    public void invalidMakeMoveTakeOwnPiece() {
        Assertions.assertThrows(InvalidMoveException.class,
                () -> game.makeMove(new ChessMove(new ChessPosition(1, 3), new ChessPosition(2, 4), null)));
    }

    @Test
    @DisplayName("Invalid Make Move Captured Piece")
    public void invalidMakeMoveCapturedPiece() throws InvalidMoveException {
        game.setBoard(TestUtilities.loadBoard("""
                |r|n|b|q|k|b|n|r|
                |p|p|p|p| |p|p|p|
                | | | | | | | | |
                | | | | |p| | | |
                | | | | | | | | |
                | | | | | |N| | |
                |P|P|P|P|P|P|P|P|
                |R|N|B|Q|K|B| |R|
                """));

        game.makeMove(new ChessMove(new ChessPosition(3, 6), new ChessPosition(5, 5), null));
        Assertions.assertThrows(InvalidMoveException.class,
                () -> game.makeMove(new ChessMove(new ChessPosition(5, 5), new ChessPosition(4, 5), null)));
    }

    @Test
    @DisplayName("Invalid Make Move Jump Enemy")
    public void invalidMakeMoveJumpEnemy() {
        game.setBoard(TestUtilities.loadBoard("""
                | | | | |k| | | |
                | | | | | | | | |
                | | | | | | | | |
                |R| |r| | | | | |
                | | | | | | | | |
                | | | | | | | | |
                | | | | | | | | |
                | | | | |K| | | |
                """));
        Assertions.assertThrows(InvalidMoveException.class,
                () -> game.makeMove(new ChessMove(new ChessPosition(5, 1), new ChessPosition(5, 5), null)));
    }

    @Test
    @DisplayName("Invalid Make Move In Check")
    public void invalidMakeMoveInCheck() {
        game.setBoard(TestUtilities.loadBoard("""
                |r|n| |q|k|b| |r|
                |p| |p|p|p|p|p|p|
                |b|p| | | | | | |
                | | | | | | | | |
                | | | | | | | | |
                |P| | |B| |n| | |
                |R|P|P| | |P|P|P|
                | |N|B|Q|K| |R| |
                """));
        //try to make an otherwise valid move that doesn't remove check
        Assertions.assertThrows(InvalidMoveException.class,
                () -> game.makeMove(new ChessMove(new ChessPosition(1, 7), new ChessPosition(1, 8), null)));
    }

    @Test
    @DisplayName("Invalid Make Move Double Move Moved Pawn")
    public void invalidMakeMoveDoubleMoveMovedPawn() {
        game.setBoard(TestUtilities.loadBoard("""
                |r|n|b|q|k|b|n|r|
                |p| |p|p|p|p|p|p|
                | | | | | | | | |
                | |p| | | | | | |
                | | | | | | | | |
                | | | | | | |P| |
                |P|P|P|P|P|P| |P|
                |R|N|B|Q|K|B|N|R|
                """));
        Assertions.assertThrows(InvalidMoveException.class,
                () -> game.makeMove(new ChessMove(new ChessPosition(3, 7), new ChessPosition(5, 7), null)));
    }


    @ParameterizedTest
    @EnumSource(value = ChessPiece.PieceType.class, names = {"QUEEN", "ROOK", "KNIGHT", "BISHOP"})
    @DisplayName("Pawn Promotion")
    public void promotionMoves(ChessPiece.PieceType promotionType) throws InvalidMoveException {
        String pieceAtStart = "After move, a piece is still present in the start position";
        String noPieceAtEnd = "After move, no piece found at the end position";
        String incorrectType = "Found piece at end position is not the correct piece type";
        String incorrectColor = "Found piece at end position is the wrong team color";

        game.setBoard(TestUtilities.loadBoard("""
                | | | | | | | | |
                | | |P| | | | | |
                | | | | | | |k| |
                | | | | | | | | |
                | | | | | | | | |
                | | | | | | | | |
                | |K| | |p| | | |
                | | | | | |Q| | |
                """));

        //White promotion
        ChessMove whitePromotion = new ChessMove(new ChessPosition(7, 3), new ChessPosition(8, 3), promotionType);
        game.makeMove(whitePromotion);

        Assertions.assertNull(game.getBoard().getPiece(whitePromotion.getStartPosition()), pieceAtStart);
        ChessPiece whiteEndPiece = game.getBoard().getPiece(whitePromotion.getEndPosition());
        Assertions.assertNotNull(whiteEndPiece, noPieceAtEnd);
        Assertions.assertEquals(promotionType, whiteEndPiece.getPieceType(), incorrectType);
        Assertions.assertEquals(ChessGame.TeamColor.WHITE, whiteEndPiece.getTeamColor(), incorrectColor);


        //Black take + promotion
        game.setTeamTurn(ChessGame.TeamColor.BLACK);
        ChessMove blackPromotion = new ChessMove(new ChessPosition(2, 5), new ChessPosition(1, 6), promotionType);
        game.makeMove(blackPromotion);

        Assertions.assertNull(game.getBoard().getPiece(blackPromotion.getStartPosition()), pieceAtStart);
        ChessPiece blackEndPiece = game.getBoard().getPiece(blackPromotion.getEndPosition());
        Assertions.assertNotNull(blackEndPiece, noPieceAtEnd);
        Assertions.assertEquals(promotionType, blackEndPiece.getPieceType(), incorrectType);
        Assertions.assertEquals(ChessGame.TeamColor.BLACK, blackEndPiece.getTeamColor(), incorrectColor);
    }
}
package passoff.chess.game;

import chess.ChessGame;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import passoff.chess.TestUtilities;

public class GameStatusTests {
    static final String INCORRECT_BLACK_CHECK = "Black is not in check but isInCheck returned true";
    static final String INCORRECT_WHITE_CHECK = "White is not in check but isInCheck returned true";
    static final String INCORRECT_BLACK_CHECKMATE = "Black is not in checkmate but isInCheckmate returned true";
    static final String INCORRECT_WHITE_CHECKMATE = "White is not in checkmate but isInCheckmate returned true";
    static final String INCORRECT_BLACK_STALEMATE = "Black is not in stalemate but isInStalemate returned true";
    static final String INCORRECT_WHITE_STALEMATE = "White is not in stalemate but isInStalemate returned true";
    static final String MISSING_WHITE_CHECK = "White is in check but isInCheck returned false";
    static final String MISSING_BLACK_CHECK = "Black is in check but isInCheck returned false";
    static final String MISSING_BLACK_CHECKMATE = "Black is in checkmate but isInCheckmate returned false";
    static final String MISSING_WHITE_CHECKMATE = "White is in checkmate but isInCheckmate returned false";
    static final String MISSING_WHITE_STALEMATE = "White is in stalemate but isInStalemate returned false";

    @Test
    @DisplayName("New Game Default Values")
    public void newGame() {
        var game = new ChessGame();
        var expectedBoard = TestUtilities.defaultBoard();
        Assertions.assertEquals(expectedBoard, game.getBoard(), "Incorrect starting board");
        Assertions.assertEquals(ChessGame.TeamColor.WHITE, game.getTeamTurn(), "Incorrect starting team turn");
    }

    @Test
    @DisplayName("Default Board No Statuses")
    public void noGameStatuses() {
        var game = new ChessGame();
        game.setBoard(TestUtilities.defaultBoard());
        game.setTeamTurn(ChessGame.TeamColor.WHITE);

        Assertions.assertFalse(game.isInCheck(ChessGame.TeamColor.BLACK), INCORRECT_BLACK_CHECK);
        Assertions.assertFalse(game.isInCheck(ChessGame.TeamColor.WHITE), INCORRECT_WHITE_CHECK);
        Assertions.assertFalse(game.isInCheckmate(ChessGame.TeamColor.BLACK), INCORRECT_BLACK_CHECKMATE);
        Assertions.assertFalse(game.isInCheckmate(ChessGame.TeamColor.WHITE), INCORRECT_WHITE_CHECKMATE);
        Assertions.assertFalse(game.isInStalemate(ChessGame.TeamColor.BLACK), INCORRECT_BLACK_STALEMATE);
        Assertions.assertFalse(game.isInStalemate(ChessGame.TeamColor.WHITE), INCORRECT_WHITE_STALEMATE);
    }


    @Test
    @DisplayName("White in Check")
    public void whiteCheck() {
        var game = new ChessGame();
        game.setBoard(TestUtilities.loadBoard("""
                | | | | | | | |k|
                | | | | | | | | |
                | | | | | | | | |
                | | | | | | | | |
                | | | | | | | | |
                | |K| | | |r| | |
                | | | | | | | | |
                | | | | | | | | |
                """));

        Assertions.assertTrue(game.isInCheck(ChessGame.TeamColor.WHITE), MISSING_WHITE_CHECK);
        Assertions.assertFalse(game.isInCheck(ChessGame.TeamColor.BLACK), INCORRECT_BLACK_CHECK);
    }


    @Test
    @DisplayName("Black in Check")
    public void blackCheck() {
        var game = new ChessGame();
        game.setBoard(TestUtilities.loadBoard("""
                | | | |K| | | | |
                | | | | | | | | |
                | | | |k| | | | |
                | | | | | | | | |
                | | | | | | | | |
                |B| | | | | | | |
                | | | | | | | | |
                | | | | | | | | |
                """));

        Assertions.assertTrue(game.isInCheck(ChessGame.TeamColor.BLACK), MISSING_BLACK_CHECK);
        Assertions.assertFalse(game.isInCheck(ChessGame.TeamColor.WHITE), INCORRECT_WHITE_CHECK);
    }


    @Test
    @DisplayName("White in Checkmate")
    public void whiteTeamCheckmate() {

        var game = new ChessGame();
        game.setBoard(TestUtilities.loadBoard("""
                | | | | | | | | |
                | | |b|q| | | | |
                | | | | | | | | |
                | | | |p| | | |k|
                | | | | | |K| | |
                | | |r| | | | | |
                | | | | |n| | | |
                | | | | | | | | |
                """));
        game.setTeamTurn(ChessGame.TeamColor.WHITE);

        Assertions.assertTrue(game.isInCheckmate(ChessGame.TeamColor.WHITE), MISSING_WHITE_CHECKMATE);
        Assertions.assertFalse(game.isInCheckmate(ChessGame.TeamColor.BLACK), INCORRECT_BLACK_CHECKMATE);
    }


    @Test
    @DisplayName("Black in Checkmate by Pawns")
    public void blackTeamPawnCheckmate() {
        var game = new ChessGame();
        game.setBoard(TestUtilities.loadBoard("""
                | | | |k| | | | |
                | | | |P|P| | | |
                | |P| | |P|P| | |
                | | | | | | | | |
                | | | | | | | | |
                | | | | | | | | |
                | | | | | | | | |
                | | | |K| | | | |
                """));
        game.setTeamTurn(ChessGame.TeamColor.BLACK);

        Assertions.assertTrue(game.isInCheckmate(ChessGame.TeamColor.BLACK), MISSING_BLACK_CHECKMATE);
        Assertions.assertFalse(game.isInCheckmate(ChessGame.TeamColor.WHITE), INCORRECT_WHITE_CHECKMATE);

    }

    @Test
    @DisplayName("Black can escape Check by capturing")
    public void escapeCheckByCapturingThreateningPiece() {

        var game = new ChessGame();
        game.setBoard(TestUtilities.loadBoard("""
                | | | | | |r|k| |
                | | | | | |P| |p|
                | | | |N| | | | |
                | | | | |B| | | |
                | | | | | | | | |
                | | | | | | | | |
                | | | | |n| | | |
                |K| | | | | | | |
                """));
        game.setTeamTurn(ChessGame.TeamColor.BLACK);

        Assertions.assertFalse(game.isInCheckmate(ChessGame.TeamColor.BLACK), INCORRECT_BLACK_CHECKMATE);
        Assertions.assertFalse(game.isInCheckmate(ChessGame.TeamColor.WHITE), INCORRECT_WHITE_CHECKMATE);
    }


    @Test
    @DisplayName("Black CANNOT escape Check by capturing")
    public void cannotEscapeCheckByCapturingThreateningPiece() {

        var game = new ChessGame();
        game.setBoard(TestUtilities.loadBoard("""
                | | | | | |r|k| |
                | | | | | |P| |p|
                | | | |N| | | | |
                | | | | |B| | | |
                | | | | | | | | |
                | | | | | | | | |
                | | | | |n| | | |
                |K| | | | | |R| |
                """));
        game.setTeamTurn(ChessGame.TeamColor.BLACK);

        Assertions.assertTrue(game.isInCheckmate(ChessGame.TeamColor.BLACK), MISSING_BLACK_CHECKMATE);
        Assertions.assertFalse(game.isInCheckmate(ChessGame.TeamColor.WHITE), INCORRECT_WHITE_CHECKMATE);
    }


    @Test
    @DisplayName("Checkmate, where blocking a threat reveals a new threat")
    public void checkmateWhereBlockingThreateningPieceOpensNewThreat() {

        var game = new ChessGame();
        game.setBoard(TestUtilities.loadBoard("""
                | | | | | | |r|k|
                | | |R| | | | | |
                | | | | | | | | |
                | | | | |r| | | |
                | | | | | | | | |
                | | |B| | | | | |
                | | | | | | | | |
                |K| | | | | | |R|
                """));
        game.setTeamTurn(ChessGame.TeamColor.BLACK);

        Assertions.assertTrue(game.isInCheckmate(ChessGame.TeamColor.BLACK), MISSING_BLACK_CHECKMATE);
        Assertions.assertFalse(game.isInCheckmate(ChessGame.TeamColor.WHITE), INCORRECT_WHITE_CHECKMATE);
    }


    @Test
    @DisplayName("Pinned King Causes Stalemate")
    public void stalemate() {
        var game = new ChessGame();
        game.setBoard(TestUtilities.loadBoard("""
                |k| | | | | | | |
                | | | | | | | |r|
                | | | | | | | | |
                | | | | |q| | | |
                | | | |n| | |K| |
                | | | | | | | | |
                | | | | | | | | |
                | | | | |b| | | |
                """));
        game.setTeamTurn(ChessGame.TeamColor.WHITE);

        Assertions.assertTrue(game.isInStalemate(ChessGame.TeamColor.WHITE), MISSING_WHITE_STALEMATE);
        Assertions.assertFalse(game.isInStalemate(ChessGame.TeamColor.BLACK), INCORRECT_BLACK_STALEMATE);
    }

    @Test
    @DisplayName("Stalemate Requires not in Check")
    public void checkmateNotStalemate() {
        var game = new ChessGame();
        game.setBoard(TestUtilities.loadBoard("""
                |k| | | | | | | |
                | | | | | | | | |
                | | | | | | | | |
                | | | | | | | | |
                | | | | | | | | |
                | | | | |P| | | |
                | | | | | | | |r|
                |K| | | | | |r| |
                """));
        game.setTeamTurn(ChessGame.TeamColor.WHITE);

        Assertions.assertFalse(game.isInStalemate(ChessGame.TeamColor.WHITE), INCORRECT_WHITE_STALEMATE);
        Assertions.assertFalse(game.isInStalemate(ChessGame.TeamColor.BLACK), INCORRECT_BLACK_STALEMATE);
    }
}
package passoff.chess.game;

import chess.ChessGame;
import chess.ChessMove;
import chess.ChessPosition;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import passoff.chess.TestUtilities;

import java.util.ArrayList;
import java.util.List;

public class ValidMovesTests {
    private static final String TRAPPED_PIECE_MOVES = "ChessGame validMoves returned valid moves for a trapped piece";

    @Test
    @DisplayName("Check Forces Movement")
    public void forcedMove() {

        var game = new ChessGame();
        game.setTeamTurn(ChessGame.TeamColor.BLACK);
        game.setBoard(TestUtilities.loadBoard("""
                    | | | | | | | | |
                    | | | | | | | | |
                    | |B| | | | | | |
                    | | | | | |K| | |
                    | | |n| | | | | |
                    | | | | | | | | |
                    | | | |q| |k| | |
                    | | | | | | | | |
                    """));

        // Knight moves
        ChessPosition knightPosition = new ChessPosition(4, 3);
        var validMoves = TestUtilities.loadMoves(knightPosition, new int[][]{{3, 5}, {6, 2}});
        assertMoves(game, validMoves, knightPosition);

        // Queen Moves
        ChessPosition queenPosition = new ChessPosition(2, 4);
        validMoves = TestUtilities.loadMoves(queenPosition, new int[][]{{3, 5}, {4, 4}});
        assertMoves(game, validMoves, queenPosition);
    }


    @Test
    @DisplayName("Piece Partially Trapped")
    public void moveIntoCheck() {

        var game = new ChessGame();
        game.setBoard(TestUtilities.loadBoard("""
                    | | | | | | | | |
                    | | | | | | | | |
                    | | | | | | | | |
                    |k|r| | | |R| |K|
                    | | | | | | | | |
                    | | | | | | | | |
                    | | | | | | | | |
                    | | | | | | | | |
                    """));

        ChessPosition rookPosition = new ChessPosition(5, 6);
        var validMoves = TestUtilities.loadMoves(rookPosition, new int[][]{
                {5, 7}, {5, 5}, {5, 4}, {5, 3}, {5, 2}
        });

        assertMoves(game, validMoves, rookPosition);
    }

    @Test
    @DisplayName("Piece Completely Trapped")
    public void rookPinnedToKing() {

        var game = new ChessGame();
        game.setBoard(TestUtilities.loadBoard("""
                    |K| | | | | | |Q|
                    | | | | | | | | |
                    | | | | | | | | |
                    | | | | | | | | |
                    | | | |r| | | | |
                    | | | | | | | | |
                    | |k| | | | | | |
                    | | | | | | | | |
                    """));

        ChessPosition position = new ChessPosition(4, 4);
        Assertions.assertTrue(game.validMoves(position).isEmpty(), TRAPPED_PIECE_MOVES);
    }


    @Test
    @DisplayName("Pieces Cannot Eliminate Check")
    public void kingInDanger() {

        var game = new ChessGame();
        game.setTeamTurn(ChessGame.TeamColor.BLACK);
        game.setBoard(TestUtilities.loadBoard("""
                    |R| | | | | | | |
                    | | | |k| | | |b|
                    | | | | |P| | | |
                    |K| |Q|n| | | | |
                    | | | | | | | | |
                    | | | | | | | |r|
                    | | | | | |p| | |
                    | |q| | | | | | |
                    """));

        //get positions
        ChessPosition kingPosition = new ChessPosition(7, 4);
        ChessPosition pawnPosition = new ChessPosition(2, 6);
        ChessPosition bishopPosition = new ChessPosition(7, 8);
        ChessPosition queenPosition = new ChessPosition(1, 2);
        ChessPosition knightPosition = new ChessPosition(5, 4);
        ChessPosition rookPosition = new ChessPosition(3, 8);


        var validMoves = TestUtilities.loadMoves(kingPosition, new int[][]{{6, 5}});

        assertMoves(game, validMoves, kingPosition);

        //make sure teams other pieces are not allowed to move
        Assertions.assertTrue(game.validMoves(pawnPosition).isEmpty(), TRAPPED_PIECE_MOVES);
        Assertions.assertTrue(game.validMoves(bishopPosition).isEmpty(), TRAPPED_PIECE_MOVES);
        Assertions.assertTrue(game.validMoves(queenPosition).isEmpty(), TRAPPED_PIECE_MOVES);
        Assertions.assertTrue(game.validMoves(knightPosition).isEmpty(), TRAPPED_PIECE_MOVES);
        Assertions.assertTrue(game.validMoves(rookPosition).isEmpty(), TRAPPED_PIECE_MOVES);
    }


    @Test
    @DisplayName("King Cannot Move Into Check")
    public void noPutSelfInDanger() {

        var game = new ChessGame();
        game.setBoard(TestUtilities.loadBoard("""
                    | | | | | | | | |
                    | | | | | | | | |
                    | | | | | | | | |
                    | | | | | | | | |
                    | | | | | |k| | |
                    | | | | | | | | |
                    | | | | | |K| | |
                    | | | | | | | | |
                    """));

        ChessPosition position = new ChessPosition(2, 6);
        var validMoves = TestUtilities.loadMoves(position, new int[][]{
                {1, 5}, {1, 6}, {1, 7}, {2, 5}, {2, 7},
        });
        assertMoves(game, validMoves, position);
    }

    @Test
    @DisplayName("Valid Moves Independent of Team Turn")
    public void validMovesOtherTeam() {
        var game = new ChessGame();
        game.setBoard(TestUtilities.defaultBoard());
        game.setTeamTurn(ChessGame.TeamColor.BLACK);

        ChessPosition position = new ChessPosition(2, 5);
        var validMoves = TestUtilities.loadMoves(position, new int[][]{
                {3, 5}, {4, 5}
        });
        assertMoves(game, validMoves, position);
    }

    private static void assertMoves(ChessGame game, List<ChessMove> validMoves, ChessPosition position) {
        var generatedMoves = game.validMoves(position);
        var actualMoves = new ArrayList<>(generatedMoves);
        TestUtilities.validateMoves(validMoves, actualMoves);
    }
}
package passoff.chess;

import chess.ChessMove;
import chess.ChessPiece;
import chess.ChessPosition;

import java.util.Collection;
import java.util.List;


public class ChessMoveTests extends EqualsTestingUtility<ChessMove> {
    public ChessMoveTests() {
        super("ChessMove", "moves");
    }

    @Override
    protected ChessMove buildOriginal() {
        return new ChessMove(new ChessPosition(2, 6), new ChessPosition(1, 5), null);
    }

    @Override
    protected Collection<ChessMove> buildAllDifferent() {
        return List.of(
                new ChessMove(new ChessPosition(1, 5), new ChessPosition(2, 6), null),
                new ChessMove(new ChessPosition(2, 4), new ChessPosition(1, 5), null),
                new ChessMove(new ChessPosition(2, 6), new ChessPosition(5, 3), null),
                new ChessMove(new ChessPosition(2, 6), new ChessPosition(1, 5), ChessPiece.PieceType.QUEEN),
                new ChessMove(new ChessPosition(2, 6), new ChessPosition(1, 5), ChessPiece.PieceType.ROOK),
                new ChessMove(new ChessPosition(2, 6), new ChessPosition(1, 5), ChessPiece.PieceType.BISHOP),
                new ChessMove(new ChessPosition(2, 6), new ChessPosition(1, 5), ChessPiece.PieceType.KNIGHT)
        );
    }

}
package passoff.chess;

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

import java.util.Collection;
import java.util.HashSet;
import java.util.Set;

/**
 * Used indirectly to help test the <pre>equals()</pre> and
 * <pre>hashCode()</pre> methods of other classes.
 * <br>
 * This class requires that implementing classes provide a few builder methods,
 * and then it automatically adds multiple tests to the evaluation suite
 * which assert that the <pre>equals()</pre> and <pre>hashCode()</pre> methods function.
 *
 * @param <T> The type to be compared during testing.
 */
public abstract class EqualsTestingUtility<T> {
    private final String className;
    private final String itemsPlural;
    private T original;
    private T equivalent;
    private Collection<T> allDifferent;

    public EqualsTestingUtility(String className, String itemsPlural) {
        this.className = className;
        this.itemsPlural = itemsPlural;
    }

    protected abstract T buildOriginal();
    protected abstract Collection<T> buildAllDifferent();


    @BeforeEach
    public void setUp() {
        original = buildOriginal();
        equivalent = buildOriginal(); // For a second time
        allDifferent = buildAllDifferent();
    }

    @Test
    @DisplayName("Equals Testing")
    public void equalsTest() {
        Assertions.assertEquals(original, equivalent,
                className + ".equals() returned false for equivalent " + itemsPlural);
        for (var different : allDifferent) {
            Assertions.assertNotEquals(original, different,
                    className + ".equals() returned true for different " + itemsPlural);
        }
    }

    @Test
    @DisplayName("HashCode Testing")
    public void hashTest() {
        Assertions.assertEquals(original.hashCode(), equivalent.hashCode(),
                className + ".hashCode() returned different values for equivalent " + itemsPlural);
        for (var different : allDifferent) {
            Assertions.assertNotEquals(original.hashCode(), different.hashCode(),
                    className + ".hashCode() returned the same value for different " + itemsPlural);
        }
    }

    @Test
    @DisplayName("Equals & HashCode Testing")
    public void hashSetTest() {
        Set<T> set = new HashSet<>();
        set.add(original);

        // Manually test insertion of original & equal items
        Assertions.assertTrue(set.contains(original),
                "[" + className + "] Original item should exist in collection after adding original item");
        Assertions.assertTrue(set.contains(equivalent),
                "[" + className + "] Equivalent item should exist in collection after only adding original item");
        Assertions.assertEquals(1, set.size(),
                "[" + className + "] Collection should contain only 1 item after a single insert");
        set.add(equivalent);
        Assertions.assertEquals(1, set.size(),
                "[" + className + "] Collection should still contain only 1 item after adding equivalent item");

        // Programmatically test insertion of all different items
        int expectedSetSize = 1;
        for (var different : allDifferent) {
            Assertions.assertFalse(set.contains(different),
                    "[" + className + "] Different item should not be present in set before insertion");
            set.add(different);
            expectedSetSize++;
            Assertions.assertEquals(expectedSetSize, set.size(),
                    "[" + className + "] New item was counted as different during insertion");
        }

    }

}
package passoff.chess;

import chess.ChessBoard;
import chess.ChessGame;
import chess.ChessPiece;
import chess.ChessPosition;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

import java.util.Arrays;
import java.util.Collection;
import java.util.List;

public class ChessPieceTests extends EqualsTestingUtility<ChessPiece> {
    public ChessPieceTests() {
        super("ChessPiece", "pieces");
    }

    @Override
    protected ChessPiece buildOriginal() {
        return new ChessPiece(ChessGame.TeamColor.WHITE, ChessPiece.PieceType.KING);
    }

    @Override
    protected Collection<ChessPiece> buildAllDifferent() {
        return List.of(
                new ChessPiece(ChessGame.TeamColor.BLACK, ChessPiece.PieceType.KING),
                new ChessPiece(ChessGame.TeamColor.WHITE, ChessPiece.PieceType.QUEEN),
                new ChessPiece(ChessGame.TeamColor.BLACK, ChessPiece.PieceType.QUEEN),
                new ChessPiece(ChessGame.TeamColor.WHITE, ChessPiece.PieceType.PAWN),
                new ChessPiece(ChessGame.TeamColor.BLACK, ChessPiece.PieceType.PAWN)
        );
    }


    @Test
    @DisplayName("Piece Move on All Pieces")
    public void pieceMoveAllPieces() {
        var board = new ChessBoard();

        // 6 piece types * 2 team colors = 12 different pieces
        Collection<ChessPiece> allPossiblePieces =
                Arrays.stream(ChessPiece.PieceType.values())
                .flatMap(pieceType -> Arrays.stream(ChessGame.TeamColor.values())
                .map(teamColor -> new ChessPiece(teamColor, pieceType)))
                .toList();

        // 8 rows * 8 cols * 12 pieces = 768 evaluations - 32 pawns on back rows
        for (int i = 1; i <= 8; i++) {
            for (int j = 1; j <= 8; j++) {
                ChessPosition position = new ChessPosition(i, j);

                for (var piece : allPossiblePieces) {
                    if (piece.getPieceType() == ChessPiece.PieceType.PAWN && (i == 1 || i == 8)) {
                        continue;
                    }

                    board.addPiece(position, piece);
                    Assertions.assertDoesNotThrow(
                            () -> piece.pieceMoves(board, position),
                            "No pieces anywhere on the board should throw an error. "
                            + "Tested: " + piece + " at " + position + ".");
                }

                board.addPiece(position, null);
            }
        }
    }

}
package passoff.chess.piecemoves;

import chess.ChessPosition;
import org.junit.jupiter.api.Test;
import passoff.chess.TestUtilities;

public class RookMoveTests {

    @Test
    public void rookMoveUntilEdge() {

        TestUtilities.validateMoves("""
                        | | | | | | | | |
                        | | | | | | | | |
                        | | | | | | | | |
                        | | | | | | | | |
                        | | | | | | | | |
                        | | | | | | | | |
                        | | |R| | | | | |
                        | | | | | | | | |
                        """,
                new ChessPosition(2, 3),
                new int[][]{
                        {2, 4}, {2, 5}, {2, 6}, {2, 7}, {2, 8},
                        {2, 2}, {2, 1},
                        {1, 3},
                        {3, 3}, {4, 3}, {5, 3}, {6, 3}, {7, 3}, {8, 3},
                }
        );
    }


    @Test
    public void rookCaptureEnemy() {
        TestUtilities.validateMoves("""
                        | | | | | | | | |
                        | | | | | | | | |
                        | | | | | | | | |
                        |N| | | | | | | |
                        |r| | | | |B| | |
                        | | | | | | | | |
                        |q| | | | | | | |
                        | | | | | | | | |
                        """,
                new ChessPosition(4, 1),
                new int[][]{
                        {5, 1},
                        {3, 1},
                        {4, 2}, {4, 3}, {4, 4}, {4, 5}, {4, 6},
                }
        );
    }


    @Test
    public void rookBlocked() {
        TestUtilities.validateMoves("""
                        | | | | | | |n|r|
                        | | | | | | | |p|
                        | | | | | | | | |
                        | | | | | | | | |
                        | | | | | | | | |
                        | | | | | | | | |
                        | | | | | | | | |
                        | | | | | | | | |
                        """,
                new ChessPosition(8, 8),
                new int[][]{}
        );
    }

}
package passoff.chess.piecemoves;

import chess.ChessPosition;
import org.junit.jupiter.api.Test;
import passoff.chess.TestUtilities;

public class BishopMoveTests {

    @Test
    public void bishopMoveUntilEdge() {
        TestUtilities.validateMoves("""
                        | | | | | | | | |
                        | | | | | | | | |
                        | | | | | | | | |
                        | | | |B| | | | |
                        | | | | | | | | |
                        | | | | | | | | |
                        | | | | | | | | |
                        | | | | | | | | |
                        """,
                new ChessPosition(5, 4),
                new int[][]{
                        {6, 5}, {7, 6}, {8, 7},
                        {4, 5}, {3, 6}, {2, 7}, {1, 8},
                        {4, 3}, {3, 2}, {2, 1},
                        {6, 3}, {7, 2}, {8, 1},
                }
        );
    }


    @Test
    public void bishopCaptureEnemy() {
        TestUtilities.validateMoves("""
                        | | | | | | | | |
                        | | | |Q| | | | |
                        | | | | | | | | |
                        | |b| | | | | | |
                        |r| | | | | | | |
                        | | | | | | | | |
                        | | | | |P| | | |
                        | | | | | | | | |
                        """,
                new ChessPosition(5, 2),
                new int[][]{
                        {6, 3}, {7, 4},
                        {4, 3}, {3, 4}, {2, 5},
                        // none
                        {6, 1},
                }
        );
    }


    @Test
    public void bishopBlocked() {
        TestUtilities.validateMoves("""
                        | | | | | | | | |
                        | | | | | | | | |
                        | | | | | | | | |
                        | | | | | | | | |
                        | | | | | | | | |
                        | | | | | | | | |
                        | | | | |R| |P| |
                        | | | | | |B| | |
                        """,
                new ChessPosition(1, 6),
                new int[][]{}
        );
    }

}
package passoff.chess.piecemoves;

import chess.ChessPosition;
import org.junit.jupiter.api.Test;
import passoff.chess.TestUtilities;

public class KingMoveTests {

    @Test
    public void kingMiddleOfBoard() {
        TestUtilities.validateMoves("""
                        | | | | | | | | |
                        | | | | | | | | |
                        | | | | | | | | |
                        | | | | | | | | |
                        | | | | | | | | |
                        | | | | | |K| | |
                        | | | | | | | | |
                        | | | | | | | | |
                        """,
                new ChessPosition(3, 6),
                new int[][]{{4, 6}, {4, 7}, {3, 7}, {2, 7}, {2, 6}, {2, 5}, {3, 5}, {4, 5}}
        );
    }


    @Test
    public void kingCaptureEnemy() {
        TestUtilities.validateMoves("""
                        | | | | | | | | |
                        | | | | | | | | |
                        | | | | | | | | |
                        | | | | | | | | |
                        | | | |N|n| | | |
                        | | | |k| | | | |
                        | | |P|b|p| | | |
                        | | | | | | | | |
                        """,
                new ChessPosition(3, 4),
                new int[][]{{4, 4}, {3, 5}, {2, 3}, {3, 3}, {4, 3}}
        );
    }


    @Test
    public void kingBlocked() {
        TestUtilities.validateMoves("""
                        | | | | | | |r|k|
                        | | | | | | |p|p|
                        | | | | | | | | |
                        | | | | | | | | |
                        | | | | | | | | |
                        | | | | | | | | |
                        | | | | | | | | |
                        | | | | | | | | |
                        """,
                new ChessPosition(8, 8),
                new int[][]{}
        );
    }

}
package passoff.chess.piecemoves;

import chess.ChessMove;
import chess.ChessPiece;
import chess.ChessPosition;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;
import passoff.chess.TestUtilities;

import java.util.ArrayList;

public class PawnMoveTests {

    @Test
    public void pawnMiddleOfBoardWhite() {
        TestUtilities.validateMoves("""
                        | | | | | | | | |
                        | | | | | | | | |
                        | | | | | | | | |
                        | | | | | | | | |
                        | | | |P| | | | |
                        | | | | | | | | |
                        | | | | | | | | |
                        | | | | | | | | |
                        """,
                new ChessPosition(4, 4),
                new int[][]{{5, 4}}
        );
    }

    @Test
    public void pawnMiddleOfBoardBlack() {
        TestUtilities.validateMoves("""
                        | | | | | | | | |
                        | | | | | | | | |
                        | | | | | | | | |
                        | | | | | | | | |
                        | | | |p| | | | |
                        | | | | | | | | |
                        | | | | | | | | |
                        | | | | | | | | |
                        """,
                new ChessPosition(4, 4),
                new int[][]{{3, 4}}
        );
    }


    @Test
    public void pawnInitialMoveWhite() {
        TestUtilities.validateMoves("""
                        | | | | | | | | |
                        | | | | | | | | |
                        | | | | | | | | |
                        | | | | | | | | |
                        | | | | | | | | |
                        | | | | | | | | |
                        | | | | |P| | | |
                        | | | | | | | | |
                        """,
                new ChessPosition(2, 5),
                new int[][]{{3, 5}, {4, 5}}
        );
    }

    @Test
    public void pawnInitialMoveBlack() {
        TestUtilities.validateMoves("""
                        | | | | | | | | |
                        | | |p| | | | | |
                        | | | | | | | | |
                        | | | | | | | | |
                        | | | | | | | | |
                        | | | | | | | | |
                        | | | | | | | | |
                        | | | | | | | | |
                        """,
                new ChessPosition(7, 3),
                new int[][]{{6, 3}, {5, 3}}
        );
    }


    @Test
    public void pawnPromotionWhite() {
        validatePromotion("""
                        | | | | | | | | |
                        | | |P| | | | | |
                        | | | | | | | | |
                        | | | | | | | | |
                        | | | | | | | | |
                        | | | | | | | | |
                        | | | | | | | | |
                        | | | | | | | | |
                        """,
                new ChessPosition(7, 3),
                new int[][]{{8, 3}}
        );
    }


    @Test
    public void edgePromotionBlack() {
        validatePromotion("""
                        | | | | | | | | |
                        | | | | | | | | |
                        | | | | | | | | |
                        | | | | | | | | |
                        | | | | | | | | |
                        | | | | | | | | |
                        | | |p| | | | | |
                        | | | | | | | | |
                        """,
                new ChessPosition(2, 3),
                new int[][]{{1, 3}}
        );
    }


    @Test
    public void pawnPromotionCapture() {
        validatePromotion("""
                        | | | | | | | | |
                        | | | | | | | | |
                        | | | | | | | | |
                        | | | | | | | | |
                        | | | | | | | | |
                        | | | | | | | | |
                        | |p| | | | | | |
                        |N| | | | | | | |
                        """,
                new ChessPosition(2, 2),
                new int[][]{{1, 1}, {1, 2}}
        );
    }


    @Test
    public void pawnAdvanceBlockedWhite() {
        TestUtilities.validateMoves("""
                        | | | | | | | | |
                        | | | | | | | | |
                        | | | | | | | | |
                        | | | |n| | | | |
                        | | | |P| | | | |
                        | | | | | | | | |
                        | | | | | | | | |
                        | | | | | | | | |
                        """,
                new ChessPosition(4, 4),
                new int[][]{}
        );
    }

    @Test
    public void pawnAdvanceBlockedBlack() {
        TestUtilities.validateMoves("""
                        | | | | | | | | |
                        | | | | | | | | |
                        | | | | | | | | |
                        | | | |p| | | | |
                        | | | |r| | | | |
                        | | | | | | | | |
                        | | | | | | | | |
                        | | | | | | | | |
                        """,
                new ChessPosition(5, 4),
                new int[][]{}
        );
    }


    @Test
    public void pawnAdvanceBlockedDoubleMoveWhite() {
        TestUtilities.validateMoves("""
                        | | | | | | | | |
                        | | | | | | | | |
                        | | | | | | | | |
                        | | | | | | | | |
                        | | | | | | |p| |
                        | | | | | | | | |
                        | | | | | | |P| |
                        | | | | | | | | |
                        """,
                new ChessPosition(2, 7),
                new int[][]{{3, 7}}
        );
    }

    @Test
    public void pawnAdvanceBlockedDoubleMoveBlack() {
        TestUtilities.validateMoves("""
                        | | | | | | | | |
                        | | |p| | | | | |
                        | | |p| | | | | |
                        | | | | | | | | |
                        | | | | | | | | |
                        | | | | | | | | |
                        | | | | | | | | |
                        | | | | | | | | |
                        """,
                new ChessPosition(7, 3),
                new int[][]{}
        );
    }


    @Test
    public void pawnCaptureWhite() {
        TestUtilities.validateMoves("""
                        | | | | | | | | |
                        | | | | | | | | |
                        | | | | | | | | |
                        | | |r| |N| | | |
                        | | | |P| | | | |
                        | | | | | | | | |
                        | | | | | | | | |
                        | | | | | | | | |
                        """,
                new ChessPosition(4, 4),
                new int[][]{{5, 3}, {5, 4}}
        );
    }

    @Test
    public void pawnCaptureBlack() {
        TestUtilities.validateMoves("""
                        | | | | | | | | |
                        | | | | | | | | |
                        | | | | | | | | |
                        | | | | | | | | |
                        | | | |p| | | | |
                        | | | |n|R| | | |
                        | | | | | | | | |
                        | | | | | | | | |
                        """,
                new ChessPosition(4, 4),
                new int[][]{{3, 5}}
        );
    }

    @Test
    public void pawnMoveFromEdgeWhite() {
        TestUtilities.validateMoves("""
                        | | | | | | | | |
                        | | | | | | | | |
                        | | | | | | | | |
                        | | | | | | | | |
                        | | | | | | | |P|
                        | | | | | | | | |
                        | | | | | | | | |
                        | | | | | | | | |
                        """,
                new ChessPosition(4, 8),
                new int[][]{{5, 8}}
        );
    }

    @Test
    public void pawnMoveFromEdgeBlack() {
        TestUtilities.validateMoves("""
                        | | | | | | | | |
                        | | | | | | | | |
                        | | | | | | | | |
                        | | | | | | | |p|
                        | | | | | | | | |
                        | | | | | | | | |
                        | | | | | | | | |
                        | | | | | | | | |
                        """,
                new ChessPosition(5, 8),
                new int[][]{{4, 8}}
        );
    }

    @Test
    public void pawnCaptureFromEdgeWhite() {
        TestUtilities.validateMoves("""
                        | | | | | | | | |
                        | | | | | | | | |
                        | | | | | | | | |
                        | | | | | | |r| |
                        | | | | | | | |P|
                        | | | | | | | | |
                        | | | | | | | | |
                        | | | | | | | | |
                        """,
                new ChessPosition(4, 8),
                new int[][]{{5, 8}, {5, 7}}
        );
    }

    @Test
    public void pawnCaptureFromEdgeBlack() {
        TestUtilities.validateMoves("""
                        | | | | | | | | |
                        | | | | | | | | |
                        | | | | | | | | |
                        | | | | | | | |p|
                        | | | | | | |R| |
                        | | | | | | | | |
                        | | | | | | | | |
                        | | | | | | | | |
                        """,
                new ChessPosition(5, 8),
                new int[][]{{4, 8}, {4, 7}}
        );
    }

    @Test
    public void pawnCaptureFromStartWhite() {
        TestUtilities.validateMoves("""
                        | | | | | | | | |
                        | | | | | | | | |
                        | | | | | | | | |
                        | | | | | | | | |
                        | | |r| | | | | |
                        | | |r| | | | | |
                        | | | |P| | | | |
                        | | | | | | | | |
                        """,
                new ChessPosition(2, 4),
                new int[][]{{3, 3}, {3, 4}, {4, 4}}
        );
    }

    @Test
    public void pawnCaptureFromStartBlack() {
        TestUtilities.validateMoves("""
                        | | | | | | | | |
                        | | | |p| | | | |
                        | | |R| | | | | |
                        | | |R| | | | | |
                        | | | | | | | | |
                        | | | | | | | | |
                        | | | | | | | | |
                        | | | | | | | | |
                        """,
                new ChessPosition(7, 4),
                new int[][]{{6, 4}, {5, 4}, {6, 3}}
        );
    }

    @Test
    public void captureAndPromoteWhite() {
        validatePromotion("""
                        | | |r| | | | | |
                        | | | |P| | | | |
                        | | | | | | | | |
                        | | | | | | | | |
                        | | | | | | | | |
                        | | | | | | | | |
                        | | | | | | | | |
                        | | | | | | | | |
                        """,
                new ChessPosition(7, 4),
                new int[][]{{8, 3}, {8, 4}}
        );
    }

    @Test
    public void captureAndPromoteBlack() {
        validatePromotion("""
                        | | | | | | | | |
                        | | | | | | | | |
                        | | | | | | | | |
                        | | | | | | | | |
                        | | | | | | | | |
                        | | | | | | | | |
                        | | | |p| | | | |
                        | | |R| | | | | |
                        """,
                new ChessPosition(2, 4),
                new int[][]{{1, 3}, {1, 4}}
        );
    }

    @Test
    public void pawnCannotCaptureBackwardWhite() {
        TestUtilities.validateMoves("""
                        | | | | | | | | |
                        | | | | | | | | |
                        | | | | | | | | |
                        | | | | | | | | |
                        | | | | | | | | |
                        | | |P| | | | | |
                        | | |r|r| | | | |
                        | | | | | | | | |
                        """,
                new ChessPosition(3, 3),
                new int[][]{{4, 3}}
        );
    }

    @Test
    public void pawnCannotCaptureBackwardBlack() {
        TestUtilities.validateMoves("""
                        | | | | | | | | |
                        | | |R|R| | | | |
                        | | |p| | | | | |
                        | | | | | | | | |
                        | | | | | | | | |
                        | | | | | | | | |
                        | | | | | | | | |
                        | | | | | | | | |
                        """,
                new ChessPosition(6, 3),
                new int[][]{{5, 3}}
        );
    }


    private static void validatePromotion(String boardText, ChessPosition startingPosition, int[][] endPositions) {
        var board = TestUtilities.loadBoard(boardText);
        var testPiece = board.getPiece(startingPosition);
        Assertions.assertNotNull(testPiece, "Could not find piece on board");
        var validMoves = new ArrayList<ChessMove>();
        for (var endPosition : endPositions) {
            var end = new ChessPosition(endPosition[0], endPosition[1]);
            validMoves.add(new ChessMove(startingPosition, end, ChessPiece.PieceType.QUEEN));
            validMoves.add(new ChessMove(startingPosition, end, ChessPiece.PieceType.BISHOP));
            validMoves.add(new ChessMove(startingPosition, end, ChessPiece.PieceType.ROOK));
            validMoves.add(new ChessMove(startingPosition, end, ChessPiece.PieceType.KNIGHT));
        }

        TestUtilities.validateMoves(board, testPiece, startingPosition, validMoves);
    }

}
package passoff.chess.piecemoves;

import chess.ChessPosition;
import org.junit.jupiter.api.Test;
import passoff.chess.TestUtilities;

public class QueenMoveTests {
    @Test
    public void queenMoveUntilEdge() {
        TestUtilities.validateMoves("""
                        | | | | | | | | |
                        | | | | | | |q| |
                        | | | | | | | | |
                        | | | | | | | | |
                        | | | | | | | | |
                        | | | | | | | | |
                        | | | | | | | | |
                        | | | | | | | | |
                        """,
                new ChessPosition(7, 7),
                new int[][]{
                        {8, 7},
                        {8, 8},
                        {7, 8},
                        {6, 8},
                        {6, 7}, {5, 7}, {4, 7}, {3, 7}, {2, 7}, {1, 7},
                        {6, 6}, {5, 5}, {4, 4}, {3, 3}, {2, 2}, {1, 1},
                        {7, 6}, {7, 5}, {7, 4}, {7, 3}, {7, 2}, {7, 1},
                        {8, 6},
                }
        );
    }


    @Test
    public void queenCaptureEnemy() {
        TestUtilities.validateMoves("""
                        |b| | | | | | | |
                        | | | | | | | | |
                        | | |R| | | | | |
                        | | | | | | | | |
                        |Q| | |p| | | | |
                        | | | | | | | | |
                        |P| |n| | | | | |
                        | | | | | | | | |
                        """,
                new ChessPosition(4, 1),
                new int[][]{
                        {5, 1}, {6, 1}, {7, 1}, {8, 1},
                        {5, 2},
                        {4, 2}, {4, 3}, {4, 4},
                        {3, 1}, {3, 2},
                        {2, 3},
                }
        );
    }


    @Test
    public void queenBlocked() {
        TestUtilities.validateMoves("""
                        | | | | | | | | |
                        | | | | | | | | |
                        | | | | | | | | |
                        | | | | | | | | |
                        | | | | | | | | |
                        | | | | | | | | |
                        |P|R| | | | | | |
                        |Q|K| | | | | | |
                        """,
                new ChessPosition(1, 1),
                new int[][]{}
        );
    }
}
package passoff.chess.piecemoves;

import chess.ChessPosition;
import org.junit.jupiter.api.Test;
import passoff.chess.TestUtilities;

public class KnightMoveTests {

    @Test
    public void knightMiddleOfBoardWhite() {
        TestUtilities.validateMoves("""
                        | | | | | | | | |
                        | | | | | | | | |
                        | | | | | | | | |
                        | | | | |N| | | |
                        | | | | | | | | |
                        | | | | | | | | |
                        | | | | | | | | |
                        | | | | | | | | |
                        """,
                new ChessPosition(5, 5),
                new int[][]{
                        {7, 6}, {6, 7}, {4, 7}, {3, 6}, {3, 4}, {4, 3}, {6, 3}, {7, 4},
                }
        );
    }

    @Test
    public void knightMiddleOfBoardBlack() {
        TestUtilities.validateMoves("""
                        | | | | | | | | |
                        | | | | | | | | |
                        | | | | | | | | |
                        | | | | |n| | | |
                        | | | | | | | | |
                        | | | | | | | | |
                        | | | | | | | | |
                        | | | | | | | | |
                        """,
                new ChessPosition(5, 5),
                new int[][]{
                        {7, 6}, {6, 7}, {4, 7}, {3, 6}, {3, 4}, {4, 3}, {6, 3}, {7, 4},
                }
        );
    }


    @Test
    public void knightEdgeOfBoardLeft() {
        TestUtilities.validateMoves("""
                        | | | | | | | | |
                        | | | | | | | | |
                        | | | | | | | | |
                        | | | | | | | | |
                        |n| | | | | | | |
                        | | | | | | | | |
                        | | | | | | | | |
                        | | | | | | | | |
                        """,
                new ChessPosition(4, 1),
                new int[][]{{6, 2}, {5, 3}, {3, 3}, {2, 2}}
        );
    }

    @Test
    public void knightEdgeOfBoardRight() {
        TestUtilities.validateMoves("""
                        | | | | | | | | |
                        | | | | | | | | |
                        | | | | | | | | |
                        | | | | | | | | |
                        | | | | | | | | |
                        | | | | | | | |n|
                        | | | | | | | | |
                        | | | | | | | | |
                        """,
                new ChessPosition(3, 8),
                new int[][]{{1, 7}, {2, 6}, {4, 6}, {5, 7}}
        );
    }

    @Test
    public void knightEdgeOfBoardBottom() {
        TestUtilities.validateMoves("""
                        | | | | | | | | |
                        | | | | | | | | |
                        | | | | | | | | |
                        | | | | | | | | |
                        | | | | | | | | |
                        | | | | | | | | |
                        | | | | | | | | |
                        | | | | | |N| | |
                        """,
                new ChessPosition(1, 6),
                new int[][]{{2, 4}, {3, 5}, {3, 7}, {2, 8}}
        );
    }

    @Test
    public void knightEdgeOfBoardTop() {
        TestUtilities.validateMoves("""
                        | | |N| | | | | |
                        | | | | | | | | |
                        | | | | | | | | |
                        | | | | | | | | |
                        | | | | | | | | |
                        | | | | | | | | |
                        | | | | | | | | |
                        | | | | | | | | |
                        """,
                new ChessPosition(8, 3),
                new int[][]{{7, 5}, {6, 4}, {6, 2}, {7, 1}}
        );
    }


    @Test
    public void knightCornerOfBoardBottomRight() {
        TestUtilities.validateMoves("""
                        | | | | | | | | |
                        | | | | | | | | |
                        | | | | | | | | |
                        | | | | | | | | |
                        | | | | | | | | |
                        | | | | | | | | |
                        | | | | | | | | |
                        | | | | | | | |N|
                        """,
                new ChessPosition(1, 8),
                new int[][]{{2, 6}, {3, 7}}
        );
    }

    @Test
    public void knightCornerOfBoardTopRight() {
        TestUtilities.validateMoves("""
                        | | | | | | | |N|
                        | | | | | | | | |
                        | | | | | | | | |
                        | | | | | | | | |
                        | | | | | | | | |
                        | | | | | | | | |
                        | | | | | | | | |
                        | | | | | | | | |
                        """,
                new ChessPosition(8, 8),
                new int[][]{{6, 7}, {7, 6}}
        );
    }

    @Test
    public void knightCornerOfBoardTopLeft() {
        TestUtilities.validateMoves("""
                        |n| | | | | | | |
                        | | | | | | | | |
                        | | | | | | | | |
                        | | | | | | | | |
                        | | | | | | | | |
                        | | | | | | | | |
                        | | | | | | | | |
                        | | | | | | | | |
                        """,
                new ChessPosition(8, 1),
                new int[][]{{7, 3}, {6, 2}}
        );
    }

    @Test
    public void knightCornerOfBoardBottomLeft() {
        TestUtilities.validateMoves("""
                        | | | | | | | | |
                        | | | | | | | | |
                        | | | | | | | | |
                        | | | | | | | | |
                        | | | | | | | | |
                        | | | | | | | | |
                        | | | | | | | | |
                        |n| | | | | | | |
                        """,
                new ChessPosition(1, 1),
                new int[][]{{2, 3}, {3, 2}}
        );
    }

    @Test
    public void knightSurroundedButNotBlocked() {
        TestUtilities.validateMoves("""
                        | | | | | | | | |
                        | | | | | | | | |
                        | | | |R|R|R| | |
                        | | | |R|N|R| | |
                        | | | |R|R|R| | |
                        | | | | | | | | |
                        | | | | | | | | |
                        | | | | | | | | |
                        """,
                new ChessPosition(5, 5),
                new int[][]{
                        {7, 6}, {6, 7}, {4, 7}, {3, 6}, {3, 4}, {4, 3}, {6, 3}, {7, 4},
                }
        );
    }

    @Test
    public void knightBlocked() {
        TestUtilities.validateMoves("""
                        | | | | | | | | |
                        | | | |R| | | | |
                        | | | | | | |P| |
                        | | | | |N| | | |
                        | | |N| | | | | |
                        | | | | | | | | |
                        | | | | | | | | |
                        | | | | | | | | |
                        """,
                new ChessPosition(5, 5),
                new int[][]{{3, 4}, {3, 6}, {4, 7}, {7, 6}, {6, 3}}
        );
    }


    @Test
    public void knightCaptureEnemy() {
        TestUtilities.validateMoves("""
                        | | | | | | | | |
                        | | | | | | | | |
                        | | | | | | | | |
                        | | | | |n| | | |
                        | | |N| | | | | |
                        | | | |P| |R| | |
                        | | | | | | | | |
                        | | | | | | | | |
                        """,
                new ChessPosition(5, 5),
                new int[][]{{7, 6}, {6, 7}, {4, 7}, {3, 6}, {3, 4}, {4, 3}, {6, 3}, {7, 4}}
        );
    }
}
package passoff.chess;

import chess.*;
import org.junit.jupiter.api.Assertions;

import java.util.ArrayList;
import java.util.Comparator;
import java.util.List;
import java.util.Map;

public class TestUtilities {
    public static void validateMoves(String boardText, ChessPosition startPosition, int[][] endPositions) {
        var board = loadBoard(boardText);
        var testPiece = board.getPiece(startPosition);
        Assertions.assertNotNull(testPiece, "Could not find piece on board");
        var validMoves = loadMoves(startPosition, endPositions);
        validateMoves(board, testPiece, startPosition, validMoves);
    }

    public static void validateMoves(ChessBoard board, ChessPiece testPiece, ChessPosition startPosition,
                                     List<ChessMove> validMoves) {
        var pieceMoves = testPiece.pieceMoves(board, startPosition);
        Assertions.assertNotNull(pieceMoves, "pieceMoves returned null");
        validateMoves(validMoves, new ArrayList<>(pieceMoves));
    }

    public static void validateMoves(List<ChessMove> expected, List<ChessMove> actual) {
        Comparator<ChessMove> comparator = Comparator.comparingInt(TestUtilities::moveToInt);
        expected.sort(comparator);
        actual.sort(comparator);

        Assertions.assertEquals(expected, actual, "Wrong moves");
    }


    private static final Map<Character, ChessPiece.PieceType> CHAR_TO_TYPE_MAP = Map.of(
            'p', ChessPiece.PieceType.PAWN,
            'n', ChessPiece.PieceType.KNIGHT,
            'r', ChessPiece.PieceType.ROOK,
            'q', ChessPiece.PieceType.QUEEN,
            'k', ChessPiece.PieceType.KING,
            'b', ChessPiece.PieceType.BISHOP);

    public static ChessBoard loadBoard(String boardText) {
        var board = new ChessBoard();
        int row = 8;
        int column = 1;
        for (var c : boardText.toCharArray()) {
            switch (c) {
                case '\n' -> {
                    column = 1;
                    row--;
                }
                case ' ' -> column++;
                case '|' -> {
                }
                default -> {
                    ChessGame.TeamColor color = Character.isLowerCase(c) ? ChessGame.TeamColor.BLACK
                            : ChessGame.TeamColor.WHITE;
                    var type = CHAR_TO_TYPE_MAP.get(Character.toLowerCase(c));
                    var position = new ChessPosition(row, column);
                    var piece = new ChessPiece(color, type);
                    board.addPiece(position, piece);
                    column++;
                }
            }
        }
        return board;
    }

    public static ChessBoard defaultBoard() {
        return loadBoard("""
                |r|n|b|q|k|b|n|r|
                |p|p|p|p|p|p|p|p|
                | | | | | | | | |
                | | | | | | | | |
                | | | | | | | | |
                | | | | | | | | |
                |P|P|P|P|P|P|P|P|
                |R|N|B|Q|K|B|N|R|
                """);
    }

    public static List<ChessMove> loadMoves(ChessPosition startPosition, int[][] endPositions) {
        var validMoves = new ArrayList<ChessMove>();
        for (var endPosition : endPositions) {
            validMoves.add(new ChessMove(startPosition,
                    new ChessPosition(endPosition[0], endPosition[1]), null));
        }
        return validMoves;
    }

    private static int positionToInt(ChessPosition position) {
        return 10 * position.getRow() + position.getColumn();
    }

    private static int moveToInt(ChessMove move) {
        return 1000 * positionToInt(move.getStartPosition()) + 10 * positionToInt(move.getEndPosition()) +
                ((move.getPromotionPiece() != null) ? move.getPromotionPiece().ordinal() + 1 : 0);
    }
}
package websocket.messages;

import java.util.Objects;

/**
 * Represents a Message the server can send through a WebSocket
 * <p>
 * Note: You can add to this class, but you should not alter the existing
 * methods.
 */
public class ServerMessage {
    ServerMessageType serverMessageType;

    public enum ServerMessageType {
        LOAD_GAME,
        ERROR,
        NOTIFICATION
    }

    public ServerMessage(ServerMessageType type) {
        this.serverMessageType = type;
    }

    public ServerMessageType getServerMessageType() {
        return this.serverMessageType;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) {
            return true;
        }
        if (!(o instanceof ServerMessage that)) {
            return false;
        }
        return getServerMessageType() == that.getServerMessageType();
    }

    @Override
    public int hashCode() {
        return Objects.hash(getServerMessageType());
    }
}package websocket.commands;

import java.util.Objects;

/**
 * Represents a command a user can send the server over a websocket
 * <p>
 * Note: You can add to this class, but you should not alter the existing
 * methods.
 */
public class UserGameCommand {

    private final CommandType commandType;

    private final String authToken;

    private final Integer gameID;

    public UserGameCommand(CommandType commandType, String authToken, Integer gameID) {
        this.commandType = commandType;
        this.authToken = authToken;
        this.gameID = gameID;
    }

    public enum CommandType {
        CONNECT,
        MAKE_MOVE,
        LEAVE,
        RESIGN
    }

    public CommandType getCommandType() {
        return commandType;
    }

    public String getAuthToken() {
        return authToken;
    }

    public Integer getGameID() {
        return gameID;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) {
            return true;
        }
        if (!(o instanceof UserGameCommand that)) {
            return false;
        }
        return getCommandType() == that.getCommandType() &&
                Objects.equals(getAuthToken(), that.getAuthToken()) &&
                Objects.equals(getGameID(), that.getGameID());
    }

    @Override
    public int hashCode() {
        return Objects.hash(getCommandType(), getAuthToken(), getGameID());
    }
}package model;

/** Represents a registered user */
public record UserData(String username, String password, String email) { }
package model;

/** Move all files in model to the shared folder for phase 5 **/

/** Represents a user authentication token */
public record AuthData(String authToken, String username) { }
package model;

import chess.ChessGame;

/** Represents a chess game with player assignments */
public record GameData(
        int gameID,
        String gameName,
        String whiteUsername,
        String blackUsername,
        ChessGame game
) {

    /** Returns a new GameData with white player set */
    public GameData withWhite(String username) {
        return new GameData(gameID, gameName, username, blackUsername, game);
    }

    /** Returns a new GameData with black player set */
    public GameData withBlack(String username) {
        return new GameData(gameID, gameName, whiteUsername, username, game);
    }
}
package chess;

/**
 * Represents a single square position on a chess board
 * <p>
 * Note: You can add to this class, but you may not alter
 * signature of the existing methods.
 */
public class ChessPosition {

    private final int row;
    private final int col;

    public ChessPosition(int row, int col) {
        this.row = row;
        this.col = col;
    }

    /**
     * @return which row this position is in
     * 1 codes for the bottom row
     */
    public int getRow() {
        return row;
    }

    /**
     * @return which column this position is in
     * 1 codes for the left row
     */
    public int getColumn() {
        return col;
    }

    @Override
    public int hashCode() {
        return 31 * row + col;
    }

    @Override
    public boolean equals(Object obj) {
        ChessPosition other = (ChessPosition) obj;
        return row == other.row && col == other.col;
    }

    @Override
    public String toString() {
        return String.format("[%d,%d]", row, col);
    }
}package chess;

/**
 * Represents moving a chess piece on a chessboard
 * <p>
 * Note: You can add to this class, but you may not alter
 * signature of the existing methods.
 */
public class ChessMove {

    private final ChessPosition startPosition;
    private final ChessPosition endPosition;
    private final ChessPiece.PieceType promotionPiece;

    public ChessMove(ChessPosition startPosition, ChessPosition endPosition,
                     ChessPiece.PieceType promotionPiece) {
        this.startPosition = startPosition;
        this.endPosition = endPosition;
        this.promotionPiece = promotionPiece;
    }

    /**
     * @return ChessPosition of starting location
     */
    public ChessPosition getStartPosition() {
        return  startPosition;
    }

    /**
     * @return ChessPosition of ending location
     */
    public ChessPosition getEndPosition() {
        return   endPosition;
    }

    /**
     * Gets the type of piece to promote a pawn to if pawn promotion is part of this
     * chess move
     *
     * @return Type of piece to promote a pawn to, or null if no promotion
     */
    public ChessPiece.PieceType getPromotionPiece() {
        return   promotionPiece;
    }

    @Override
    public int hashCode() {
        int result = startPosition.hashCode();
        result = 31 * result + endPosition.hashCode();
        result = 31 * result + (promotionPiece != null ? promotionPiece.hashCode() : 0);
        return result;
    }

    @Override
    public boolean equals(Object obj) {
        ChessMove other =  (ChessMove) obj;
        boolean position = startPosition.equals(other.startPosition) && endPosition.equals(other.endPosition);
        boolean promotion = (promotionPiece != null? promotionPiece.equals(other.promotionPiece) : other.promotionPiece == null  );
        return position && promotion;
    }

    @Override
    public String toString() {
        return String.format("%s%s%s",  startPosition, endPosition, promotionPiece);
    }
}package chess;

import java.util.Collection;
import java.util.HashSet;
import java.util.Objects;

/**
 * Manages a chess game, making moves on a board.
 */
public class ChessGame {

    private TeamColor currentTurn;
    private ChessBoard board;
    private ChessPosition enPassantTarget;
    private boolean hasMoved;

    public ChessGame() {
        this.board = new ChessBoard();
        this.board.resetBoard(); // set up all pieces
        this.currentTurn = TeamColor.WHITE;
    }

    public enum TeamColor {
        WHITE, BLACK
    }

    public TeamColor getTeamTurn() {
        return currentTurn;
    }

    public void setTeamTurn(TeamColor team) {
        this.currentTurn = team;
    }

    public ChessBoard getBoard() {
        return board;
    }

    public void setBoard(ChessBoard board) {
        this.board = board;
    }

    /**
     * Gets all valid moves for a piece at a position.
     */
    public Collection<ChessMove> validMoves(ChessPosition startPosition) {
        ChessPiece piece = board.getPiece(startPosition);
        if (piece == null) {
            return null;
        }

        Collection<ChessMove> moves = new HashSet<>(piece.pieceMoves(board, startPosition));

        // filter out moves that leave own king in check
        moves.removeIf(move -> {
            ChessBoard temp = board.copy();
            makeMoveOnBoard(temp, move);
            return isInCheck(piece.getTeamColor(), temp);
        });

        return moves;
    }

    /**
     * Makes a move in the actual game.
     */
    public void makeMove(ChessMove move) throws InvalidMoveException {
        ChessPiece piece = board.getPiece(move.getStartPosition());

        if (piece == null) {
            throw new InvalidMoveException("No piece at start position.");
        }
        if (piece.getTeamColor() != currentTurn) {
            throw new InvalidMoveException("Not your turn!");
        }

        Collection<ChessMove> legalMoves = validMoves(move.getStartPosition());
        if (legalMoves == null || !legalMoves.contains(move)) {
            throw new InvalidMoveException("Invalid move!");
        }



        // apply the move
        makeMoveOnBoard(board, move);

        // switch turn
        currentTurn = (currentTurn == TeamColor.WHITE) ? TeamColor.BLACK : TeamColor.WHITE;
    }

    /**
     * Checks if a team is in check.
     */
    public boolean isInCheck(TeamColor teamColor) {
        return isInCheck(teamColor, board);
    }

    /**
     * Checks if a team is in checkmate.
     */
    public boolean isInCheckmate(TeamColor teamColor) {
        return isInCheck(teamColor) && !hasAnyLegalMoves(teamColor);
    }

    public boolean isInStalemate(TeamColor teamColor) {
        return !isInCheck(teamColor) && !hasAnyLegalMoves(teamColor);
    }

    /**
     * Helper: checks if the given team has at least one valid move.
     */
    private boolean hasAnyLegalMoves(TeamColor teamColor) {
        for (int row = 1; row <= 8; row++) {
            for (int col = 1; col <= 8; col++) {
                ChessPosition pos = new ChessPosition(row, col);
                ChessPiece piece = board.getPiece(pos);
                if (piece != null && piece.getTeamColor() == teamColor) {
                    if (!validMoves(pos).isEmpty()) {
                        return true;
                    }
                }
            }
        }
        return false;
    }

    // ----------------- Helper Methods -----------------

    /**
     * Apply a move to a given board (does not check legality).
     */
    private void makeMoveOnBoard(ChessBoard b, ChessMove move) {
        ChessPiece movingPiece = b.getPiece(move.getStartPosition());

        // handle promotion
        if (move.getPromotionPiece() != null) {
            movingPiece = new ChessPiece(movingPiece.getTeamColor(), move.getPromotionPiece());
        }

        // move the piece
        b.addPiece(move.getEndPosition(), movingPiece);
        b.addPiece(move.getStartPosition(), null); // clear old square
    }

    /**
     * Check if a team is in check on a given board state.
     */
    private boolean isInCheck(TeamColor teamColor, ChessBoard b) {
        ChessPosition kingPos = findKing(teamColor, b);
        if (kingPos == null) {
            return false;
        }

        for (int row = 1; row <= 8; row++) {
            for (int col = 1; col <= 8; col++) {
                ChessPosition pos = new ChessPosition(row, col);
                ChessPiece piece = b.getPiece(pos);
                if (piece == null || piece.getTeamColor() == teamColor) {
                    continue;
                }

                Collection<ChessMove> moves = piece.pieceMoves(b, pos);
                for (ChessMove m : moves) {
                    if (m.getEndPosition().equals(kingPos)) {
                        return true;
                    }
                }
            }
        }
        return false;
    }

    /**
     * Find the king of a given team on a board.
     */
    private ChessPosition findKing(TeamColor teamColor, ChessBoard b) {
        for (int row = 1; row <= 8; row++) {
            for (int col = 1; col <= 8; col++) {
                ChessPosition pos = new ChessPosition(row, col);
                ChessPiece piece = b.getPiece(pos);
                if (piece != null &&
                        piece.getTeamColor() == teamColor &&
                        piece.getPieceType() == ChessPiece.PieceType.KING) {
                    return pos;
                }
            }
        }
        return null;
    }

    // ----------------- Object Overrides -----------------

    @Override
    public boolean equals(Object o) {
        if (this == o) {
            return true;
        }
        if (!(o instanceof ChessGame)) {
            return false;
        }
        ChessGame chessGame = (ChessGame) o;
        return currentTurn == chessGame.currentTurn &&
                Objects.equals(board, chessGame.board);
    }

    @Override
    public int hashCode() {
        return Objects.hash(currentTurn, board);
    }
}package chess;

import java.util.ArrayList;
import java.util.Collection;
import java.util.List;

public class CalculatePieceMoves {

    public static void exploreDirections(
            ChessBoard board, ChessPosition myPosition,
            ChessPiece piece, int drow, int dcol,
            boolean repeat, List<ChessMove> moves) {

        int newRow = myPosition.getRow() + drow;
        int newCol = myPosition.getColumn() + dcol;

        while (newRow >= 1 && newCol >= 1 && newRow <= 8 && newCol <= 8) {
            ChessPosition newPos = new ChessPosition(newRow, newCol);
            ChessPiece occupyingPiece = board.getPiece(newPos);

            if (occupyingPiece == null) {
                moves.add(new ChessMove(myPosition, newPos, null));
            } else {
                if (piece.getTeamColor() != occupyingPiece.getTeamColor()) {
                    moves.add(new ChessMove(myPosition, newPos, null));
                }
                break;
            }

            if (!repeat) {
                break;
            }
            newRow += drow;
            newCol += dcol;
        }
    }

    public static Collection<ChessMove> bishopmoves(
            ChessBoard board, ChessPosition myPosition, ChessPiece piece) {

        List<ChessMove> moves = new ArrayList<>();
        int[][] dirs = {{1, -1}, {-1, -1}, {1, 1}, {-1, 1}};
        for (int[] dir : dirs) {
            exploreDirections(board, myPosition, piece, dir[0], dir[1], true, moves);
        }
        return moves;
    }

    public static Collection<ChessMove> rookmoves(
            ChessBoard board, ChessPosition myPosition, ChessPiece piece) {

        List<ChessMove> moves = new ArrayList<>();
        int[][] dirs = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};
        for (int[] dir : dirs) {
            exploreDirections(board, myPosition, piece, dir[0], dir[1], true, moves);
        }
        return moves;
    }

    public static Collection<ChessMove> queenmoves(
            ChessBoard board, ChessPosition myPosition, ChessPiece piece) {

        List<ChessMove> moves = new ArrayList<>();
        int[][] dirs = {
                {1, -1}, {-1, -1}, {1, 1}, {-1, 1},
                {1, 0}, {-1, 0}, {0, 1}, {0, -1}
        };
        for (int[] dir : dirs) {
            exploreDirections(board, myPosition, piece, dir[0], dir[1], true, moves);
        }
        return moves;
    }

    public static Collection<ChessMove> kingmoves(
            ChessBoard board, ChessPosition myPosition, ChessPiece piece) {

        List<ChessMove> moves = new ArrayList<>();
        int[][] dirs = {
                {1, -1}, {-1, -1}, {1, 1}, {-1, 1},
                {1, 0}, {-1, 0}, {0, 1}, {0, -1}
        };
        for (int[] dir : dirs) {
            exploreDirections(board, myPosition, piece, dir[0], dir[1], false, moves);
        }
        return moves;
    }

    public static Collection<ChessMove> knightmoves(
            ChessBoard board, ChessPosition myPosition, ChessPiece piece) {

        List<ChessMove> moves = new ArrayList<>();
        int[][] dirs = {
                {2, -1}, {2, 1}, {-2, 1}, {-2, -1},
                {1, 2}, {-1, 2}, {1, -2}, {-1, -2}
        };
        for (int[] dir : dirs) {
            exploreDirections(board, myPosition, piece, dir[0], dir[1], false, moves);
        }
        return moves;
    }

    public static Collection<ChessMove> pawnmoves(
            ChessBoard board, ChessPosition myPosition, ChessPiece piece) {

        List<ChessMove> moves = new ArrayList<>();
        int row = myPosition.getRow();
        int col = myPosition.getColumn();

        int dir = piece.getTeamColor() == ChessGame.TeamColor.WHITE ? 1 : -1;
        int newRow = row + dir;

        addForwardMoves(board, myPosition, piece, moves, row, col, dir, newRow);
        addDiagonalMoves(board, myPosition, piece, moves, col, dir, newRow);

        return moves;
    }

    private static void addForwardMoves(
            ChessBoard board, ChessPosition pos, ChessPiece piece,
            List<ChessMove> moves, int row, int col, int dir, int newRow) {

        ChessPosition forward = new ChessPosition(newRow, col);
        ChessPiece frontPiece = board.getPiece(forward);
        if (frontPiece != null) {
            return;
        }

        if (isPromotion(piece, newRow)) {
            addPromotions(moves, pos, forward);
        } else {
            moves.add(new ChessMove(pos, forward, null));
        }

        boolean startRow =
                (piece.getTeamColor() == ChessGame.TeamColor.WHITE && row == 2)
                        || (piece.getTeamColor() == ChessGame.TeamColor.BLACK && row == 7);

        if (startRow) {
            ChessPosition doublePos = new ChessPosition(row + dir + dir, col);
            if (board.getPiece(doublePos) == null) {
                moves.add(new ChessMove(pos, doublePos, null));
            }
        }
    }

    private static void addDiagonalMoves(
            ChessBoard board, ChessPosition pos, ChessPiece piece,
            List<ChessMove> moves, int col, int dir, int newRow) {

        int[] diagonals = {1, -1};
        for (int d : diagonals) {
            int newCol = col + d;
            if (!inBounds(newRow, newCol)) {
                continue;
            }

            ChessPosition diagPos = new ChessPosition(newRow, newCol);
            ChessPiece diagPiece = board.getPiece(diagPos);
            if (diagPiece == null) {
                continue;
            }

            if (piece.getTeamColor() != diagPiece.getTeamColor()) {
                if (isPromotion(piece, newRow)) {
                    addPromotions(moves, pos, diagPos);
                } else {
                    moves.add(new ChessMove(pos, diagPos, null));
                }
            }
        }
    }

    private static void addPromotions(List<ChessMove> moves, ChessPosition from, ChessPosition to) {
        for (ChessPiece.PieceType t : ChessPiece.PieceType.values()) {
            if (t != ChessPiece.PieceType.KING && t != ChessPiece.PieceType.PAWN) {
                moves.add(new ChessMove(from, to, t));
            }
        }
    }

    private static boolean isPromotion(ChessPiece piece, int row) {
        return (piece.getTeamColor() == ChessGame.TeamColor.WHITE && row == 8)
                || (piece.getTeamColor() == ChessGame.TeamColor.BLACK && row == 1);
    }

    private static boolean inBounds(int row, int col) {
        return row >= 1 && row <= 8 && col >= 1 && col <= 8;
    }
}
package chess;

import java.util.Collection;
import java.util.List;

/**
 * Represents a single chess piece
 * <p>
 * Note: You can add to this class, but you may not alter
 * signature of the existing methods.
 */
public class ChessPiece {

    private final ChessGame.TeamColor pieceColor;
    private final PieceType type;

    public ChessPiece(ChessGame.TeamColor pieceColor, ChessPiece.PieceType type) {
        this.pieceColor = pieceColor;
        this.type = type;
    }

    /**
     * The various different chess piece options
     */
    public enum PieceType {
        KING,
        QUEEN,
        BISHOP,
        KNIGHT,
        ROOK,
        PAWN
    }

    /**
     * @return Which team this chess piece belongs to
     */
    public ChessGame.TeamColor getTeamColor() {
        return pieceColor;
    }

    /**
     * @return which type of chess piece this piece is
     */
    public PieceType getPieceType() {
        return type;
    }

    /**
     * Calculates all the positions a chess piece can move to
     * Does not take into account moves that are illegal due to leaving the king in
     * danger
     *
     * @return Collection of valid moves
     */
    public Collection<ChessMove> pieceMoves(ChessBoard board, ChessPosition myPosition) {
        switch(type){
            case BISHOP:
                return CalculatePieceMoves.bishopmoves(board, myPosition, this);
            case KING:
                return CalculatePieceMoves.kingmoves(board, myPosition, this);
            case KNIGHT:
                return CalculatePieceMoves.knightmoves(board, myPosition, this);
            case PAWN:
                return CalculatePieceMoves.pawnmoves(board, myPosition, this);
            case QUEEN:
                return CalculatePieceMoves.queenmoves(board, myPosition, this);
            case ROOK:
                return CalculatePieceMoves.rookmoves(board, myPosition, this);
            default:
                return List.of();
        }
    }

    @Override
    public int hashCode() {
        int result = 31 * ( pieceColor!= null ?  pieceColor.hashCode() : 0 );
        result = 31 * result + (type != null ? type.hashCode() : 0 );
        return result;
    }

    @Override
    public boolean equals(Object obj) {
        if (obj == null) {
            return false;
        }
        ChessPiece  other = (ChessPiece) obj;
        return this.pieceColor == other.pieceColor &&  this.type == other.type;
    }
}package chess;

import java.util.Arrays;

/**
 * A chessboard that can hold and rearrange chess pieces.
 * <p>
 * Note: You can add to this class, but you may not alter
 * signature of the existing methods.
 */
public class ChessBoard {

    ChessPiece[][] squares = new ChessPiece[8][8];
    public ChessBoard() {

    }

    /**
     * Adds a chess piece to the chessboard
     *
     * @param position where to add the piece to
     * @param piece    the piece to add
     */
    public void addPiece(ChessPosition position, ChessPiece piece) {
        squares[position.getRow()-1][position.getColumn()-1] = piece;
    }

    /**
     * Gets a chess piece on the chessboard
     *
     * @param position The position to get the piece from
     * @return Either the piece at the position, or null if no piece is at that
     * position
     */
    public ChessPiece getPiece(ChessPosition position) {
        return squares[position.getRow()-1][position.getColumn()-1];
    }

    public ChessBoard copy(){
        ChessBoard newBoard = new ChessBoard();
        for(int row = 1; row <= 8; row++){
            for(int col = 1; col <= 8; col++){
                ChessPosition pos = new ChessPosition(row, col);
                ChessPiece piece = this.getPiece(pos);
                if(piece != null){
                    newBoard.addPiece(pos, new ChessPiece(piece.getTeamColor(), piece.getPieceType()));
                }
            }
        }
        return newBoard;
    }


    /**
     * Sets the board to the default starting board
     * (How the game of chess normally starts)
     */
    public void resetBoard() {
        addPiece(new ChessPosition(1, 1), new ChessPiece(ChessGame.TeamColor.WHITE, ChessPiece.PieceType.ROOK));
        addPiece(new ChessPosition(1, 2), new ChessPiece(ChessGame.TeamColor.WHITE, ChessPiece.PieceType.KNIGHT));
        addPiece(new ChessPosition(1, 3), new ChessPiece(ChessGame.TeamColor.WHITE, ChessPiece.PieceType.BISHOP));
        addPiece(new ChessPosition(1, 4), new ChessPiece(ChessGame.TeamColor.WHITE, ChessPiece.PieceType.QUEEN));
        addPiece(new ChessPosition(1, 5), new ChessPiece(ChessGame.TeamColor.WHITE, ChessPiece.PieceType.KING));
        addPiece(new ChessPosition(1, 6), new ChessPiece(ChessGame.TeamColor.WHITE, ChessPiece.PieceType.BISHOP));
        addPiece(new ChessPosition(1, 7), new ChessPiece(ChessGame.TeamColor.WHITE, ChessPiece.PieceType.KNIGHT));
        addPiece(new ChessPosition(1, 8), new ChessPiece(ChessGame.TeamColor.WHITE, ChessPiece.PieceType.ROOK));
        for(int i = 1; i <= 8; i++) {
            addPiece(new ChessPosition(2, i), new ChessPiece(ChessGame.TeamColor.WHITE, ChessPiece.PieceType.PAWN));
        }
        addPiece(new ChessPosition(8, 1), new ChessPiece(ChessGame.TeamColor.BLACK, ChessPiece.PieceType.ROOK));
        addPiece(new ChessPosition(8, 2), new ChessPiece(ChessGame.TeamColor.BLACK, ChessPiece.PieceType.KNIGHT));
        addPiece(new ChessPosition(8, 3), new ChessPiece(ChessGame.TeamColor.BLACK, ChessPiece.PieceType.BISHOP));
        addPiece(new ChessPosition(8, 4), new ChessPiece(ChessGame.TeamColor.BLACK, ChessPiece.PieceType.QUEEN));
        addPiece(new ChessPosition(8, 5), new ChessPiece(ChessGame.TeamColor.BLACK, ChessPiece.PieceType.KING));
        addPiece(new ChessPosition(8, 6), new ChessPiece(ChessGame.TeamColor.BLACK, ChessPiece.PieceType.BISHOP));
        addPiece(new ChessPosition(8, 7), new ChessPiece(ChessGame.TeamColor.BLACK, ChessPiece.PieceType.KNIGHT));
        addPiece(new ChessPosition(8, 8), new ChessPiece(ChessGame.TeamColor.BLACK, ChessPiece.PieceType.ROOK));
        for(int i = 1; i <= 8; i++) {
            addPiece(new ChessPosition(7, i), new ChessPiece(ChessGame.TeamColor.BLACK, ChessPiece.PieceType.PAWN));
        }

    }

    @Override
    public boolean equals(Object obj) {
        ChessBoard other =  (ChessBoard) obj;
        return Arrays.deepEquals(squares, other.squares);
    }

    @Override
    public int hashCode() {
        return Arrays.deepHashCode(squares);
    }
}package chess;

/**
 * Indicates an invalid move was made in a game
 */
public class InvalidMoveException extends Exception {

    public InvalidMoveException() {}

    public InvalidMoveException(String message) {
        super(message);
    }
}package passoff.chess.game;

import chess.ChessGame;
import chess.ChessMove;
import chess.ChessPosition;
import chess.InvalidMoveException;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

public class FullGameTest {
    @Test
    @DisplayName("Full Game Checkmate")
    public void scholarsMate() throws InvalidMoveException {
        var game = new ChessGame();
        game.makeMove(new ChessMove(new ChessPosition(2, 5), new ChessPosition(4, 5), null));
        /*
                |r|n|b|q|k|b|n|r|
                |p|p|p|p|p|p|p|p|
                | | | | | | | | |
                | | | | | | | | |
                | | | | |P| | | |
                | | | | | | | | |
                |P|P|P|P| |P|P|P|
                |R|N|B|Q|K|B|N|R|
         */
        game.makeMove(new ChessMove(new ChessPosition(7, 5), new ChessPosition(5, 5), null));
        /*
                |r|n|b|q|k|b|n|r|
                |p|p|p|p| |p|p|p|
                | | | | | | | | |
                | | | | |p| | | |
                | | | | |P| | | |
                | | | | | | | | |
                |P|P|P|P| |P|P|P|
                |R|N|B|Q|K|B|N|R|
         */
        game.makeMove(new ChessMove(new ChessPosition(1, 6), new ChessPosition(4, 3), null));
        /*
                |r|n|b|q|k|b|n|r|
                |p|p|p|p| |p|p|p|
                | | | | | | | | |
                | | | | |p| | | |
                | | |B| |P| | | |
                | | | | | | | | |
                |P|P|P|P| |P|P|P|
                |R|N|B|Q|K| |N|R|
         */
        game.makeMove(new ChessMove(new ChessPosition(8, 7), new ChessPosition(6, 6), null));
        /*
                |r|n|b|q|k|b| |r|
                |p|p|p|p| |p|p|p|
                | | | | | |n| | |
                | | | | |p| | | |
                | | |B| |P| | | |
                | | | | | | | | |
                |P|P|P|P| |P|P|P|
                |R|N|B|Q|K| |N|R|
         */
        game.makeMove(new ChessMove(new ChessPosition(1, 4), new ChessPosition(5, 8), null));
        /*
                |r|n|b|q|k|b| |r|
                |p|p|p|p| |p|p|p|
                | | | | | |n| | |
                | | | | |p| | |Q|
                | | |B| |P| | | |
                | | | | | | | | |
                |P|P|P|P| |P|P|P|
                |R|N|B| |K| |N|R|
         */
        game.makeMove(new ChessMove(new ChessPosition(8, 2), new ChessPosition(6, 3), null));
        /*
                |r| |b|q|k|b| |r|
                |p|p|p|p| |p|p|p|
                | | |n| | |n| | |
                | | | | |p| | |Q|
                | | |B| |P| | | |
                | | | | | | | | |
                |P|P|P|P| |P|P|P|
                |R|N|B| |K| |N|R|
         */
        game.makeMove(new ChessMove(new ChessPosition(5, 8), new ChessPosition(7, 6), null));
        /*
                |r| |b|q|k|b| |r|
                |p|p|p|p| |Q|p|p|
                | | |n| | |n| | |
                | | | | |p| | | |
                | | |B| |P| | | |
                | | | | | | | | |
                |P|P|P|P| |P|P|P|
                |R|N|B| |K| |N|R|
         */
        Assertions.assertTrue(game.isInCheck(ChessGame.TeamColor.BLACK), GameStatusTests.MISSING_BLACK_CHECK);
        Assertions.assertFalse(game.isInCheck(ChessGame.TeamColor.WHITE), GameStatusTests.INCORRECT_WHITE_CHECK);
        Assertions.assertTrue(game.isInCheckmate(ChessGame.TeamColor.BLACK), GameStatusTests.MISSING_BLACK_CHECKMATE);
        Assertions.assertFalse(game.isInCheckmate(ChessGame.TeamColor.WHITE), GameStatusTests.INCORRECT_WHITE_CHECKMATE);
        Assertions.assertFalse(game.isInStalemate(ChessGame.TeamColor.BLACK), GameStatusTests.INCORRECT_BLACK_STALEMATE);
        Assertions.assertFalse(game.isInStalemate(ChessGame.TeamColor.WHITE), GameStatusTests.INCORRECT_WHITE_STALEMATE);
    }
}
package passoff.chess.game;

import chess.ChessGame;
import chess.ChessMove;
import chess.ChessPosition;
import chess.InvalidMoveException;
import passoff.chess.EqualsTestingUtility;
import passoff.chess.TestUtilities;

import java.util.ArrayList;
import java.util.Collection;

public class ChessGameTests extends EqualsTestingUtility<ChessGame> {
    public ChessGameTests() {
        super("ChessGame", "games");
    }

    @Override
    protected ChessGame buildOriginal() {
        return new ChessGame();
    }

    @Override
    protected Collection<ChessGame> buildAllDifferent() {
        Collection<ChessGame> differentGames = new ArrayList<>();

        try {
            // Different team turn
            ChessGame game1 = new ChessGame();
            game1.setTeamTurn(ChessGame.TeamColor.BLACK);
            differentGames.add(game1);

            // Move pawn
            ChessGame game2 = new ChessGame();
            game2.makeMove(new ChessMove(
                    new ChessPosition(2, 5),
                    new ChessPosition(4, 5),
                    null));
            differentGames.add(game2);

            // Move knight
            ChessGame game3 = new ChessGame();
            game3.makeMove(new ChessMove(
                    new ChessPosition(1, 7),
                    new ChessPosition(3, 6),
                    null));
            differentGames.add(game3);

            // Set board
            ChessGame game4 = new ChessGame();
            game4.setBoard(TestUtilities.loadBoard("""
                    | | | |R| | | | |
                    | | | | | | | | |
                    | | |p|n|p| | | |
                    |R| |n|k|r| | |R|
                    | | |p|q| | | | |
                    | | | | | |K| | |
                    | | | | |P| | | |
                    | | | |R| | | | |
                    """));
            differentGames.add(game4);

        } catch (InvalidMoveException e) {
            throw new RuntimeException("All moves in ChessGameTests are valid and should be allowed.", e);
        }

        return differentGames;
    }
}
package passoff.chess.game;

import chess.*;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.EnumSource;
import passoff.chess.TestUtilities;

public class MakeMoveTests {
    private static final String WRONG_BOARD = "Board not correct after move made";
    private ChessGame game;

    @BeforeEach
    public void setUp() {
        game = new ChessGame();
        game.setTeamTurn(ChessGame.TeamColor.WHITE);
        game.setBoard(TestUtilities.defaultBoard());
    }

    @Test
    @DisplayName("Make Valid King Move")
    public void makeValidKingMove() throws InvalidMoveException {
        game.setBoard(TestUtilities.loadBoard("""
                | | | | | | | | |
                |p| | | | | | |k|
                | | | | | | | | |
                | | | | | | | | |
                | | | | | | | | |
                | | | | | | | | |
                | | | | | | | | |
                | |K| | | | | | |
                """));
        game.setTeamTurn(ChessGame.TeamColor.WHITE);

        var kingStartPosition = new ChessPosition(1, 2);
        var kingEndPosition = new ChessPosition(1, 1);
        game.makeMove(new ChessMove(kingStartPosition, kingEndPosition, null));

        Assertions.assertEquals(TestUtilities.loadBoard("""
                | | | | | | | | |
                |p| | | | | | |k|
                | | | | | | | | |
                | | | | | | | | |
                | | | | | | | | |
                | | | | | | | | |
                | | | | | | | | |
                |K| | | | | | | |
                """), game.getBoard(), WRONG_BOARD);
    }

    @Test
    @DisplayName("Make Valid Queen Move")
    public void makeValidQueenMove() throws InvalidMoveException {
        game.setBoard(TestUtilities.loadBoard("""
                | | | | | | | | |
                | | | | | | | | |
                | | | | | | |q| |
                | | | | | | | | |
                | | | | | | | | |
                | | | | | | | | |
                | | | | | | | | |
                |K| |k| | | | | |
                """));
        game.setTeamTurn(ChessGame.TeamColor.BLACK);

        var queenStartPosition = new ChessPosition(6, 7);
        var queenEndPosition = new ChessPosition(1, 2);
        game.makeMove(new ChessMove(queenStartPosition, queenEndPosition, null));

        Assertions.assertEquals(TestUtilities.loadBoard("""
                | | | | | | | | |
                | | | | | | | | |
                | | | | | | | | |
                | | | | | | | | |
                | | | | | | | | |
                | | | | | | | | |
                | | | | | | | | |
                |K|q|k| | | | | |
                """), game.getBoard(), WRONG_BOARD);
    }

    @Test
    @DisplayName("Make Valid Rook Move")
    public void makeValidRookMove() throws InvalidMoveException {
        game.setBoard(TestUtilities.loadBoard("""
                | | | | |k| | | |
                | | | | | | | | |
                | | | | | | | | |
                | | | | | | | | |
                | | | | | | | | |
                | | | | | | | |R|
                | | | | | | | | |
                |K| | | | | | | |
                """));
        game.setTeamTurn(ChessGame.TeamColor.WHITE);

        var rookStartPosition = new ChessPosition(3, 8);
        var rookEndPosition = new ChessPosition(7, 8);
        game.makeMove(new ChessMove(rookStartPosition, rookEndPosition, null));

        Assertions.assertEquals(TestUtilities.loadBoard("""
                | | | | |k| | | |
                | | | | | | | |R|
                | | | | | | | | |
                | | | | | | | | |
                | | | | | | | | |
                | | | | | | | | |
                | | | | | | | | |
                |K| | | | | | | |
                """), game.getBoard(), WRONG_BOARD);
    }

    @Test
    @DisplayName("Make Valid Knight Move")
    public void makeValidKnightMove() throws InvalidMoveException {
        game.setBoard(TestUtilities.loadBoard("""
                | | | | |k| | | |
                | | | | | | | | |
                | | |n| | | | | |
                | | | | | | | | |
                | | | | | | | | |
                | | | | | | | | |
                | | | | | | | |P|
                | | | | |K| | | |
                """));
        game.setTeamTurn(ChessGame.TeamColor.BLACK);

        var knightStartPosition = new ChessPosition(6, 3);
        var knightEndPosition = new ChessPosition(4, 4);
        game.makeMove(new ChessMove(knightStartPosition, knightEndPosition, null));

        Assertions.assertEquals(TestUtilities.loadBoard("""
                | | | | |k| | | |
                | | | | | | | | |
                | | | | | | | | |
                | | | | | | | | |
                | | | |n| | | | |
                | | | | | | | | |
                | | | | | | | |P|
                | | | | |K| | | |
                """), game.getBoard(), WRONG_BOARD);
    }

    @Test
    @DisplayName("Make Valid Bishop Move")
    public void makeValidBishopMove() throws InvalidMoveException {
        game.setBoard(TestUtilities.loadBoard("""
                | | | | |k| | | |
                |p| | | | | | | |
                | | | | | | | | |
                | | | | | | | | |
                | | | | | | | | |
                | | | | | | | | |
                | | | | | | | | |
                | | |B| |K| | | |
                """));
        game.setTeamTurn(ChessGame.TeamColor.WHITE);

        var bishopStartPosition = new ChessPosition(1, 3);
        var bishopEndPosition = new ChessPosition(6, 8);
        game.makeMove(new ChessMove(bishopStartPosition, bishopEndPosition, null));

        Assertions.assertEquals(TestUtilities.loadBoard("""
                | | | | |k| | | |
                |p| | | | | | | |
                | | | | | | | |B|
                | | | | | | | | |
                | | | | | | | | |
                | | | | | | | | |
                | | | | | | | | |
                | | | | |K| | | |
                """), game.getBoard(), WRONG_BOARD);
    }

    @Test
    @DisplayName("Make Valid Pawn Move")
    public void makeValidPawnMove() throws InvalidMoveException {
        game.setBoard(TestUtilities.loadBoard("""
                | |k| | | | | | |
                | |p| | | | | | |
                | | | | | | | | |
                | | | | | | | | |
                | | | | | | | | |
                | | | | | | | | |
                | | | | | | |P| |
                | | | | | | |K| |
                """));
        game.setTeamTurn(ChessGame.TeamColor.BLACK);

        var pawnStartPosition = new ChessPosition(7, 2);
        var pawnEndPosition = new ChessPosition(6, 2);
        game.makeMove(new ChessMove(pawnStartPosition, pawnEndPosition, null));

        Assertions.assertEquals(TestUtilities.loadBoard("""
                | |k| | | | | | |
                | | | | | | | | |
                | |p| | | | | | |
                | | | | | | | | |
                | | | | | | | | |
                | | | | | | | | |
                | | | | | | |P| |
                | | | | | | |K| |
                """), game.getBoard(), WRONG_BOARD);
    }

    @Test
    @DisplayName("Make Move Changes Team Turn")
    public void makeMoveChangesTurn() throws InvalidMoveException {
        String failureMessage = "Team color not changed after move made";

        game.makeMove(new ChessMove(new ChessPosition(2, 5), new ChessPosition(4, 5), null));
        Assertions.assertEquals(ChessGame.TeamColor.BLACK, game.getTeamTurn(), failureMessage);

        game.makeMove(new ChessMove(new ChessPosition(7, 5), new ChessPosition(5, 5), null));
        Assertions.assertEquals(ChessGame.TeamColor.WHITE, game.getTeamTurn(), failureMessage);
    }

    @Test
    @DisplayName("Invalid Make Move Too Far")
    public void invalidMakeMoveTooFar() {
        Assertions.assertThrows(InvalidMoveException.class,
                () -> game.makeMove(new ChessMove(new ChessPosition(2, 1), new ChessPosition(5, 1), null)));
    }

    @Test
    @DisplayName("Invalid Make Move Pawn Diagonal No Capture")
    public void invalidMakeMovePawnDiagonalNoCapture() {
        Assertions.assertThrows(InvalidMoveException.class,
                () -> game.makeMove(new ChessMove(new ChessPosition(2, 1), new ChessPosition(3, 2), null)));
    }

    @Test
    @DisplayName("Invalid Make Move Out Of Turn")
    public void invalidMakeMoveOutOfTurn() {
        Assertions.assertThrows(InvalidMoveException.class,
                () -> game.makeMove(new ChessMove(new ChessPosition(7, 5), new ChessPosition(6, 5), null)));
    }

    @Test
    @DisplayName("Invalid Make Move Through Piece")
    public void invalidMakeMoveThroughPiece() {
        Assertions.assertThrows(InvalidMoveException.class,
                () -> game.makeMove(new ChessMove(new ChessPosition(1, 1), new ChessPosition(4, 1), null)));
    }

    @Test
    @DisplayName("Invalid Make Move No Piece")
    public void invalidMakeMoveNoPiece() {
        //starting position does not have a piece
        Assertions.assertThrows(InvalidMoveException.class,
                () -> game.makeMove(new ChessMove(new ChessPosition(4, 4), new ChessPosition(4, 5), null)));
    }

    @Test
    @DisplayName("Invalid Make Move Invalid Move")
    public void invalidMakeMoveInvalidMove() {
        //not a move the piece can ever take
        Assertions.assertThrows(InvalidMoveException.class,
                () -> game.makeMove(new ChessMove(new ChessPosition(8, 7), new ChessPosition(5, 5), null)));
    }

    @Test
    @DisplayName("Invalid Make Move Take Own Piece")
    public void invalidMakeMoveTakeOwnPiece() {
        Assertions.assertThrows(InvalidMoveException.class,
                () -> game.makeMove(new ChessMove(new ChessPosition(1, 3), new ChessPosition(2, 4), null)));
    }

    @Test
    @DisplayName("Invalid Make Move Captured Piece")
    public void invalidMakeMoveCapturedPiece() throws InvalidMoveException {
        game.setBoard(TestUtilities.loadBoard("""
                |r|n|b|q|k|b|n|r|
                |p|p|p|p| |p|p|p|
                | | | | | | | | |
                | | | | |p| | | |
                | | | | | | | | |
                | | | | | |N| | |
                |P|P|P|P|P|P|P|P|
                |R|N|B|Q|K|B| |R|
                """));

        game.makeMove(new ChessMove(new ChessPosition(3, 6), new ChessPosition(5, 5), null));
        Assertions.assertThrows(InvalidMoveException.class,
                () -> game.makeMove(new ChessMove(new ChessPosition(5, 5), new ChessPosition(4, 5), null)));
    }

    @Test
    @DisplayName("Invalid Make Move Jump Enemy")
    public void invalidMakeMoveJumpEnemy() {
        game.setBoard(TestUtilities.loadBoard("""
                | | | | |k| | | |
                | | | | | | | | |
                | | | | | | | | |
                |R| |r| | | | | |
                | | | | | | | | |
                | | | | | | | | |
                | | | | | | | | |
                | | | | |K| | | |
                """));
        Assertions.assertThrows(InvalidMoveException.class,
                () -> game.makeMove(new ChessMove(new ChessPosition(5, 1), new ChessPosition(5, 5), null)));
    }

    @Test
    @DisplayName("Invalid Make Move In Check")
    public void invalidMakeMoveInCheck() {
        game.setBoard(TestUtilities.loadBoard("""
                |r|n| |q|k|b| |r|
                |p| |p|p|p|p|p|p|
                |b|p| | | | | | |
                | | | | | | | | |
                | | | | | | | | |
                |P| | |B| |n| | |
                |R|P|P| | |P|P|P|
                | |N|B|Q|K| |R| |
                """));
        //try to make an otherwise valid move that doesn't remove check
        Assertions.assertThrows(InvalidMoveException.class,
                () -> game.makeMove(new ChessMove(new ChessPosition(1, 7), new ChessPosition(1, 8), null)));
    }

    @Test
    @DisplayName("Invalid Make Move Double Move Moved Pawn")
    public void invalidMakeMoveDoubleMoveMovedPawn() {
        game.setBoard(TestUtilities.loadBoard("""
                |r|n|b|q|k|b|n|r|
                |p| |p|p|p|p|p|p|
                | | | | | | | | |
                | |p| | | | | | |
                | | | | | | | | |
                | | | | | | |P| |
                |P|P|P|P|P|P| |P|
                |R|N|B|Q|K|B|N|R|
                """));
        Assertions.assertThrows(InvalidMoveException.class,
                () -> game.makeMove(new ChessMove(new ChessPosition(3, 7), new ChessPosition(5, 7), null)));
    }


    @ParameterizedTest
    @EnumSource(value = ChessPiece.PieceType.class, names = {"QUEEN", "ROOK", "KNIGHT", "BISHOP"})
    @DisplayName("Pawn Promotion")
    public void promotionMoves(ChessPiece.PieceType promotionType) throws InvalidMoveException {
        String pieceAtStart = "After move, a piece is still present in the start position";
        String noPieceAtEnd = "After move, no piece found at the end position";
        String incorrectType = "Found piece at end position is not the correct piece type";
        String incorrectColor = "Found piece at end position is the wrong team color";

        game.setBoard(TestUtilities.loadBoard("""
                | | | | | | | | |
                | | |P| | | | | |
                | | | | | | |k| |
                | | | | | | | | |
                | | | | | | | | |
                | | | | | | | | |
                | |K| | |p| | | |
                | | | | | |Q| | |
                """));

        //White promotion
        ChessMove whitePromotion = new ChessMove(new ChessPosition(7, 3), new ChessPosition(8, 3), promotionType);
        game.makeMove(whitePromotion);

        Assertions.assertNull(game.getBoard().getPiece(whitePromotion.getStartPosition()), pieceAtStart);
        ChessPiece whiteEndPiece = game.getBoard().getPiece(whitePromotion.getEndPosition());
        Assertions.assertNotNull(whiteEndPiece, noPieceAtEnd);
        Assertions.assertEquals(promotionType, whiteEndPiece.getPieceType(), incorrectType);
        Assertions.assertEquals(ChessGame.TeamColor.WHITE, whiteEndPiece.getTeamColor(), incorrectColor);


        //Black take + promotion
        game.setTeamTurn(ChessGame.TeamColor.BLACK);
        ChessMove blackPromotion = new ChessMove(new ChessPosition(2, 5), new ChessPosition(1, 6), promotionType);
        game.makeMove(blackPromotion);

        Assertions.assertNull(game.getBoard().getPiece(blackPromotion.getStartPosition()), pieceAtStart);
        ChessPiece blackEndPiece = game.getBoard().getPiece(blackPromotion.getEndPosition());
        Assertions.assertNotNull(blackEndPiece, noPieceAtEnd);
        Assertions.assertEquals(promotionType, blackEndPiece.getPieceType(), incorrectType);
        Assertions.assertEquals(ChessGame.TeamColor.BLACK, blackEndPiece.getTeamColor(), incorrectColor);
    }
}
package passoff.chess.game;

import chess.ChessGame;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import passoff.chess.TestUtilities;

public class GameStatusTests {
    static final String INCORRECT_BLACK_CHECK = "Black is not in check but isInCheck returned true";
    static final String INCORRECT_WHITE_CHECK = "White is not in check but isInCheck returned true";
    static final String INCORRECT_BLACK_CHECKMATE = "Black is not in checkmate but isInCheckmate returned true";
    static final String INCORRECT_WHITE_CHECKMATE = "White is not in checkmate but isInCheckmate returned true";
    static final String INCORRECT_BLACK_STALEMATE = "Black is not in stalemate but isInStalemate returned true";
    static final String INCORRECT_WHITE_STALEMATE = "White is not in stalemate but isInStalemate returned true";
    static final String MISSING_WHITE_CHECK = "White is in check but isInCheck returned false";
    static final String MISSING_BLACK_CHECK = "Black is in check but isInCheck returned false";
    static final String MISSING_BLACK_CHECKMATE = "Black is in checkmate but isInCheckmate returned false";
    static final String MISSING_WHITE_CHECKMATE = "White is in checkmate but isInCheckmate returned false";
    static final String MISSING_WHITE_STALEMATE = "White is in stalemate but isInStalemate returned false";

    @Test
    @DisplayName("New Game Default Values")
    public void newGame() {
        var game = new ChessGame();
        var expectedBoard = TestUtilities.defaultBoard();
        Assertions.assertEquals(expectedBoard, game.getBoard(), "Incorrect starting board");
        Assertions.assertEquals(ChessGame.TeamColor.WHITE, game.getTeamTurn(), "Incorrect starting team turn");
    }

    @Test
    @DisplayName("Default Board No Statuses")
    public void noGameStatuses() {
        var game = new ChessGame();
        game.setBoard(TestUtilities.defaultBoard());
        game.setTeamTurn(ChessGame.TeamColor.WHITE);

        Assertions.assertFalse(game.isInCheck(ChessGame.TeamColor.BLACK), INCORRECT_BLACK_CHECK);
        Assertions.assertFalse(game.isInCheck(ChessGame.TeamColor.WHITE), INCORRECT_WHITE_CHECK);
        Assertions.assertFalse(game.isInCheckmate(ChessGame.TeamColor.BLACK), INCORRECT_BLACK_CHECKMATE);
        Assertions.assertFalse(game.isInCheckmate(ChessGame.TeamColor.WHITE), INCORRECT_WHITE_CHECKMATE);
        Assertions.assertFalse(game.isInStalemate(ChessGame.TeamColor.BLACK), INCORRECT_BLACK_STALEMATE);
        Assertions.assertFalse(game.isInStalemate(ChessGame.TeamColor.WHITE), INCORRECT_WHITE_STALEMATE);
    }


    @Test
    @DisplayName("White in Check")
    public void whiteCheck() {
        var game = new ChessGame();
        game.setBoard(TestUtilities.loadBoard("""
                | | | | | | | |k|
                | | | | | | | | |
                | | | | | | | | |
                | | | | | | | | |
                | | | | | | | | |
                | |K| | | |r| | |
                | | | | | | | | |
                | | | | | | | | |
                """));

        Assertions.assertTrue(game.isInCheck(ChessGame.TeamColor.WHITE), MISSING_WHITE_CHECK);
        Assertions.assertFalse(game.isInCheck(ChessGame.TeamColor.BLACK), INCORRECT_BLACK_CHECK);
    }


    @Test
    @DisplayName("Black in Check")
    public void blackCheck() {
        var game = new ChessGame();
        game.setBoard(TestUtilities.loadBoard("""
                | | | |K| | | | |
                | | | | | | | | |
                | | | |k| | | | |
                | | | | | | | | |
                | | | | | | | | |
                |B| | | | | | | |
                | | | | | | | | |
                | | | | | | | | |
                """));

        Assertions.assertTrue(game.isInCheck(ChessGame.TeamColor.BLACK), MISSING_BLACK_CHECK);
        Assertions.assertFalse(game.isInCheck(ChessGame.TeamColor.WHITE), INCORRECT_WHITE_CHECK);
    }


    @Test
    @DisplayName("White in Checkmate")
    public void whiteTeamCheckmate() {

        var game = new ChessGame();
        game.setBoard(TestUtilities.loadBoard("""
                | | | | | | | | |
                | | |b|q| | | | |
                | | | | | | | | |
                | | | |p| | | |k|
                | | | | | |K| | |
                | | |r| | | | | |
                | | | | |n| | | |
                | | | | | | | | |
                """));
        game.setTeamTurn(ChessGame.TeamColor.WHITE);

        Assertions.assertTrue(game.isInCheckmate(ChessGame.TeamColor.WHITE), MISSING_WHITE_CHECKMATE);
        Assertions.assertFalse(game.isInCheckmate(ChessGame.TeamColor.BLACK), INCORRECT_BLACK_CHECKMATE);
    }


    @Test
    @DisplayName("Black in Checkmate by Pawns")
    public void blackTeamPawnCheckmate() {
        var game = new ChessGame();
        game.setBoard(TestUtilities.loadBoard("""
                | | | |k| | | | |
                | | | |P|P| | | |
                | |P| | |P|P| | |
                | | | | | | | | |
                | | | | | | | | |
                | | | | | | | | |
                | | | | | | | | |
                | | | |K| | | | |
                """));
        game.setTeamTurn(ChessGame.TeamColor.BLACK);

        Assertions.assertTrue(game.isInCheckmate(ChessGame.TeamColor.BLACK), MISSING_BLACK_CHECKMATE);
        Assertions.assertFalse(game.isInCheckmate(ChessGame.TeamColor.WHITE), INCORRECT_WHITE_CHECKMATE);

    }

    @Test
    @DisplayName("Black can escape Check by capturing")
    public void escapeCheckByCapturingThreateningPiece() {

        var game = new ChessGame();
        game.setBoard(TestUtilities.loadBoard("""
                | | | | | |r|k| |
                | | | | | |P| |p|
                | | | |N| | | | |
                | | | | |B| | | |
                | | | | | | | | |
                | | | | | | | | |
                | | | | |n| | | |
                |K| | | | | | | |
                """));
        game.setTeamTurn(ChessGame.TeamColor.BLACK);

        Assertions.assertFalse(game.isInCheckmate(ChessGame.TeamColor.BLACK), INCORRECT_BLACK_CHECKMATE);
        Assertions.assertFalse(game.isInCheckmate(ChessGame.TeamColor.WHITE), INCORRECT_WHITE_CHECKMATE);
    }


    @Test
    @DisplayName("Black CANNOT escape Check by capturing")
    public void cannotEscapeCheckByCapturingThreateningPiece() {

        var game = new ChessGame();
        game.setBoard(TestUtilities.loadBoard("""
                | | | | | |r|k| |
                | | | | | |P| |p|
                | | | |N| | | | |
                | | | | |B| | | |
                | | | | | | | | |
                | | | | | | | | |
                | | | | |n| | | |
                |K| | | | | |R| |
                """));
        game.setTeamTurn(ChessGame.TeamColor.BLACK);

        Assertions.assertTrue(game.isInCheckmate(ChessGame.TeamColor.BLACK), MISSING_BLACK_CHECKMATE);
        Assertions.assertFalse(game.isInCheckmate(ChessGame.TeamColor.WHITE), INCORRECT_WHITE_CHECKMATE);
    }


    @Test
    @DisplayName("Checkmate, where blocking a threat reveals a new threat")
    public void checkmateWhereBlockingThreateningPieceOpensNewThreat() {

        var game = new ChessGame();
        game.setBoard(TestUtilities.loadBoard("""
                | | | | | | |r|k|
                | | |R| | | | | |
                | | | | | | | | |
                | | | | |r| | | |
                | | | | | | | | |
                | | |B| | | | | |
                | | | | | | | | |
                |K| | | | | | |R|
                """));
        game.setTeamTurn(ChessGame.TeamColor.BLACK);

        Assertions.assertTrue(game.isInCheckmate(ChessGame.TeamColor.BLACK), MISSING_BLACK_CHECKMATE);
        Assertions.assertFalse(game.isInCheckmate(ChessGame.TeamColor.WHITE), INCORRECT_WHITE_CHECKMATE);
    }


    @Test
    @DisplayName("Pinned King Causes Stalemate")
    public void stalemate() {
        var game = new ChessGame();
        game.setBoard(TestUtilities.loadBoard("""
                |k| | | | | | | |
                | | | | | | | |r|
                | | | | | | | | |
                | | | | |q| | | |
                | | | |n| | |K| |
                | | | | | | | | |
                | | | | | | | | |
                | | | | |b| | | |
                """));
        game.setTeamTurn(ChessGame.TeamColor.WHITE);

        Assertions.assertTrue(game.isInStalemate(ChessGame.TeamColor.WHITE), MISSING_WHITE_STALEMATE);
        Assertions.assertFalse(game.isInStalemate(ChessGame.TeamColor.BLACK), INCORRECT_BLACK_STALEMATE);
    }

    @Test
    @DisplayName("Stalemate Requires not in Check")
    public void checkmateNotStalemate() {
        var game = new ChessGame();
        game.setBoard(TestUtilities.loadBoard("""
                |k| | | | | | | |
                | | | | | | | | |
                | | | | | | | | |
                | | | | | | | | |
                | | | | | | | | |
                | | | | |P| | | |
                | | | | | | | |r|
                |K| | | | | |r| |
                """));
        game.setTeamTurn(ChessGame.TeamColor.WHITE);

        Assertions.assertFalse(game.isInStalemate(ChessGame.TeamColor.WHITE), INCORRECT_WHITE_STALEMATE);
        Assertions.assertFalse(game.isInStalemate(ChessGame.TeamColor.BLACK), INCORRECT_BLACK_STALEMATE);
    }
}
package passoff.chess.game;

import chess.ChessGame;
import chess.ChessMove;
import chess.ChessPosition;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import passoff.chess.TestUtilities;

import java.util.ArrayList;
import java.util.List;

public class ValidMovesTests {
    private static final String TRAPPED_PIECE_MOVES = "ChessGame validMoves returned valid moves for a trapped piece";

    @Test
    @DisplayName("Check Forces Movement")
    public void forcedMove() {

        var game = new ChessGame();
        game.setTeamTurn(ChessGame.TeamColor.BLACK);
        game.setBoard(TestUtilities.loadBoard("""
                    | | | | | | | | |
                    | | | | | | | | |
                    | |B| | | | | | |
                    | | | | | |K| | |
                    | | |n| | | | | |
                    | | | | | | | | |
                    | | | |q| |k| | |
                    | | | | | | | | |
                    """));

        // Knight moves
        ChessPosition knightPosition = new ChessPosition(4, 3);
        var validMoves = TestUtilities.loadMoves(knightPosition, new int[][]{{3, 5}, {6, 2}});
        assertMoves(game, validMoves, knightPosition);

        // Queen Moves
        ChessPosition queenPosition = new ChessPosition(2, 4);
        validMoves = TestUtilities.loadMoves(queenPosition, new int[][]{{3, 5}, {4, 4}});
        assertMoves(game, validMoves, queenPosition);
    }


    @Test
    @DisplayName("Piece Partially Trapped")
    public void moveIntoCheck() {

        var game = new ChessGame();
        game.setBoard(TestUtilities.loadBoard("""
                    | | | | | | | | |
                    | | | | | | | | |
                    | | | | | | | | |
                    |k|r| | | |R| |K|
                    | | | | | | | | |
                    | | | | | | | | |
                    | | | | | | | | |
                    | | | | | | | | |
                    """));

        ChessPosition rookPosition = new ChessPosition(5, 6);
        var validMoves = TestUtilities.loadMoves(rookPosition, new int[][]{
                {5, 7}, {5, 5}, {5, 4}, {5, 3}, {5, 2}
        });

        assertMoves(game, validMoves, rookPosition);
    }

    @Test
    @DisplayName("Piece Completely Trapped")
    public void rookPinnedToKing() {

        var game = new ChessGame();
        game.setBoard(TestUtilities.loadBoard("""
                    |K| | | | | | |Q|
                    | | | | | | | | |
                    | | | | | | | | |
                    | | | | | | | | |
                    | | | |r| | | | |
                    | | | | | | | | |
                    | |k| | | | | | |
                    | | | | | | | | |
                    """));

        ChessPosition position = new ChessPosition(4, 4);
        Assertions.assertTrue(game.validMoves(position).isEmpty(), TRAPPED_PIECE_MOVES);
    }


    @Test
    @DisplayName("Pieces Cannot Eliminate Check")
    public void kingInDanger() {

        var game = new ChessGame();
        game.setTeamTurn(ChessGame.TeamColor.BLACK);
        game.setBoard(TestUtilities.loadBoard("""
                    |R| | | | | | | |
                    | | | |k| | | |b|
                    | | | | |P| | | |
                    |K| |Q|n| | | | |
                    | | | | | | | | |
                    | | | | | | | |r|
                    | | | | | |p| | |
                    | |q| | | | | | |
                    """));

        //get positions
        ChessPosition kingPosition = new ChessPosition(7, 4);
        ChessPosition pawnPosition = new ChessPosition(2, 6);
        ChessPosition bishopPosition = new ChessPosition(7, 8);
        ChessPosition queenPosition = new ChessPosition(1, 2);
        ChessPosition knightPosition = new ChessPosition(5, 4);
        ChessPosition rookPosition = new ChessPosition(3, 8);


        var validMoves = TestUtilities.loadMoves(kingPosition, new int[][]{{6, 5}});

        assertMoves(game, validMoves, kingPosition);

        //make sure teams other pieces are not allowed to move
        Assertions.assertTrue(game.validMoves(pawnPosition).isEmpty(), TRAPPED_PIECE_MOVES);
        Assertions.assertTrue(game.validMoves(bishopPosition).isEmpty(), TRAPPED_PIECE_MOVES);
        Assertions.assertTrue(game.validMoves(queenPosition).isEmpty(), TRAPPED_PIECE_MOVES);
        Assertions.assertTrue(game.validMoves(knightPosition).isEmpty(), TRAPPED_PIECE_MOVES);
        Assertions.assertTrue(game.validMoves(rookPosition).isEmpty(), TRAPPED_PIECE_MOVES);
    }


    @Test
    @DisplayName("King Cannot Move Into Check")
    public void noPutSelfInDanger() {

        var game = new ChessGame();
        game.setBoard(TestUtilities.loadBoard("""
                    | | | | | | | | |
                    | | | | | | | | |
                    | | | | | | | | |
                    | | | | | | | | |
                    | | | | | |k| | |
                    | | | | | | | | |
                    | | | | | |K| | |
                    | | | | | | | | |
                    """));

        ChessPosition position = new ChessPosition(2, 6);
        var validMoves = TestUtilities.loadMoves(position, new int[][]{
                {1, 5}, {1, 6}, {1, 7}, {2, 5}, {2, 7},
        });
        assertMoves(game, validMoves, position);
    }

    @Test
    @DisplayName("Valid Moves Independent of Team Turn")
    public void validMovesOtherTeam() {
        var game = new ChessGame();
        game.setBoard(TestUtilities.defaultBoard());
        game.setTeamTurn(ChessGame.TeamColor.BLACK);

        ChessPosition position = new ChessPosition(2, 5);
        var validMoves = TestUtilities.loadMoves(position, new int[][]{
                {3, 5}, {4, 5}
        });
        assertMoves(game, validMoves, position);
    }

    private static void assertMoves(ChessGame game, List<ChessMove> validMoves, ChessPosition position) {
        var generatedMoves = game.validMoves(position);
        var actualMoves = new ArrayList<>(generatedMoves);
        TestUtilities.validateMoves(validMoves, actualMoves);
    }
}
package passoff.chess.extracredit;

import chess.*;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import passoff.chess.TestUtilities;

/**
 * Tests if the ChessGame implementation can handle En Passant moves
 * En Passant is a situational move in chess taken directly after your opponent has double moved a pawn
 * If their pawn moves next to one of your pawns, so it passes where your pawn could have captured it, you
 * may capture their pawn with your pawn as if they had only moved a single space. You may only take this move
 * if you do so the turn directly following the pawns double move. This is as if you had caught their
 * pawn "in passing", or translated to French: "En Passant".
 */
public class EnPassantTests {

    @Test
    @DisplayName("White En Passant Right")
    public void enPassantWhiteRight() throws InvalidMoveException {
        ChessBoard board = TestUtilities.loadBoard("""
                | | | | | | | | |
                | | |p| | | | | |
                | | | | | | | | |
                | |P| | | | | | |
                | | | | | | | |k|
                | | | | | | | | |
                | | | | | | | | |
                | | | | |K| | | |
                """);
        ChessMove setupMove = new ChessMove(new ChessPosition(7, 3), new ChessPosition(5, 3), null);
        /*
                | | | | | | | | |
                | | | | | | | | |
                | | | | | | | | |
                | |P|p| | | | | |
                | | | | | | | |k|
                | | | | | | | | |
                | | | | | | | | |
                | | | | |K| | | |
         */

        ChessMove enPassantMove = new ChessMove(new ChessPosition(5, 2), new ChessPosition(6, 3), null);
        ChessBoard endBoard = TestUtilities.loadBoard("""
                | | | | | | | | |
                | | | | | | | | |
                | | |P| | | | | |
                | | | | | | | | |
                | | | | | | | |k|
                | | | | | | | | |
                | | | | | | | | |
                | | | | |K| | | |
                """);

        assertValidEnPassant(board, ChessGame.TeamColor.BLACK, setupMove, enPassantMove, endBoard);
    }


    @Test
    @DisplayName("White En Passant Left")
    public void enPassantWhiteLeft() throws InvalidMoveException {
        ChessBoard board = TestUtilities.loadBoard("""
                | | | | | | | | |
                | | |p| | | | | |
                | | | | | | | | |
                | | | |P| | | | |
                | | | | | | | |k|
                | | | | | | | | |
                | | | | | | | | |
                | | | | |K| | | |
                """);

        ChessMove setupMove = new ChessMove(new ChessPosition(7, 3), new ChessPosition(5, 3), null);
        /*
                | | | | | | | | |
                | | | | | | | | |
                | | | | | | | | |
                | | |p|P| | | | |
                | | | | | | | |k|
                | | | | | | | | |
                | | | | | | | | |
                | | | | |K| | | |
         */
        ChessMove enPassantMove = new ChessMove(new ChessPosition(5, 4), new ChessPosition(6, 3), null);
        ChessBoard endBoard = TestUtilities.loadBoard("""
                | | | | | | | | |
                | | | | | | | | |
                | | |P| | | | | |
                | | | | | | | | |
                | | | | | | | |k|
                | | | | | | | | |
                | | | | | | | | |
                | | | | |K| | | |
                """);

        assertValidEnPassant(board, ChessGame.TeamColor.BLACK, setupMove, enPassantMove, endBoard);
    }


    @Test
    @DisplayName("Black En Passant Right")
    public void enPassantBlackRight() throws InvalidMoveException {
        ChessBoard board = TestUtilities.loadBoard("""
                | | | |k| | | | |
                | | | | | | | | |
                | | | | | | | | |
                |K| | | | | | | |
                | | | | | |p| | |
                | | | | | | | | |
                | | | | | | |P| |
                | | | | | | | | |
                """);
        ChessMove setupMove = new ChessMove(new ChessPosition(2, 7), new ChessPosition(4, 7), null);
        /*
                | | | |k| | | | |
                | | | | | | | | |
                | | | | | | | | |
                |K| | | | | | | |
                | | | | | |p|P| |
                | | | | | | | | |
                | | | | | | | | |
                | | | | | | | | |
         */
        ChessMove enPassantMove = new ChessMove(new ChessPosition(4, 6), new ChessPosition(3, 7), null);
        ChessBoard endBoard = TestUtilities.loadBoard("""
                | | | |k| | | | |
                | | | | | | | | |
                | | | | | | | | |
                |K| | | | | | | |
                | | | | | | | | |
                | | | | | | |p| |
                | | | | | | | | |
                | | | | | | | | |
                """);

        assertValidEnPassant(board, ChessGame.TeamColor.WHITE, setupMove, enPassantMove, endBoard);
    }


    @Test
    @DisplayName("Black En Passant Left")
    public void enPassantBlackLeft() throws InvalidMoveException {
        ChessBoard board = TestUtilities.loadBoard("""
                | | | |k| | | | |
                | | | | | | | | |
                | | | | | | | | |
                |K| | | | | | | |
                | | | | | | | |p|
                | | | | | | | | |
                | | | | | | |P| |
                | | | | | | | | |
                """);
        ChessMove setupMove = new ChessMove(new ChessPosition(2, 7), new ChessPosition(4, 7), null);
        /*
                | | | |k| | | | |
                | | | | | | | | |
                | | | | | | | | |
                |K| | | | | | | |
                | | | | | | |P|p|
                | | | | | | | | |
                | | | | | | | | |
                | | | | | | | | |
         */
        ChessMove enPassantMove = new ChessMove(new ChessPosition(4, 8), new ChessPosition(3, 7), null);
        ChessBoard endBoard = TestUtilities.loadBoard("""
                | | | |k| | | | |
                | | | | | | | | |
                | | | | | | | | |
                |K| | | | | | | |
                | | | | | | | | |
                | | | | | | |p| |
                | | | | | | | | |
                | | | | | | | | |
                """);
        assertValidEnPassant(board, ChessGame.TeamColor.WHITE, setupMove, enPassantMove, endBoard);
    }


    @Test
    @DisplayName("Can Only En Passant on Next Turn")
    public void missedEnPassant() throws InvalidMoveException {
        ChessBoard board = TestUtilities.loadBoard("""
                | | | | |k| | | |
                | | |p| | | | | |
                | | | | | | | |P|
                | |P| | | | | | |
                | | | | | | | | |
                | | | | | | | |p|
                | | | | | | | | |
                | | | |K| | | | |
                """);
        ChessGame game = new ChessGame();
        game.setBoard(board);
        game.setTeamTurn(ChessGame.TeamColor.BLACK);

        //move black piece 2 spaces
        game.makeMove(new ChessMove(new ChessPosition(7, 3), new ChessPosition(5, 3), null));
        /*
                | | | | |k| | | |
                | | | | | | | | |
                | | | | | | | |P|
                | |P|p| | | | | |
                | | | | | | | | |
                | | | | | | | |p|
                | | | | | | | | |
                | | | |K| | | | |
         */

        //filler moves
        game.makeMove(new ChessMove(new ChessPosition(6, 8), new ChessPosition(7, 8), null));
        game.makeMove(new ChessMove(new ChessPosition(3, 8), new ChessPosition(2, 8), null));
        /*
                | | | | |k| | | |
                | | | | | | | |P|
                | | | | | | | | |
                | |P|p| | | | | |
                | | | | | | | | |
                | | | | | | | | |
                | | | | | | | |p|
                | | | |K| | | | |
         */

        //make sure pawn cannot do En Passant move
        ChessPosition enPassantPosition = new ChessPosition(5, 2);
        ChessMove enPassantMove = new ChessMove(enPassantPosition, new ChessPosition(6, 3), null);
        Assertions.assertFalse(game.validMoves(enPassantPosition).contains(enPassantMove),
                "ChessGame validMoves contained a En Passant move after the move became invalid");
    }

    private void assertValidEnPassant(ChessBoard board, ChessGame.TeamColor turn, ChessMove setupMove,
                                      ChessMove enPassantMove, ChessBoard endBoard) throws InvalidMoveException {
        ChessGame game = new ChessGame();
        game.setBoard(board);
        game.setTeamTurn(turn);

        //setup prior move for en passant
        game.makeMove(setupMove);

        //make sure pawn has En Passant move
        Assertions.assertTrue(game.validMoves(enPassantMove.getStartPosition()).contains(enPassantMove),
                "ChessGame validMoves did not contain a valid En Passant move");

        //en passant move works correctly
        Assertions.assertDoesNotThrow(() -> game.makeMove(enPassantMove));
        Assertions.assertEquals(endBoard, game.getBoard(), "Incorrect Board after En Passant Move");
    }

}
package passoff.chess.extracredit;

import chess.*;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Order;
import org.junit.jupiter.api.Test;
import passoff.chess.TestUtilities;

/**
 * Tests if the ChessGame implementation can handle Castling moves
 * Castling is a situational move the king can make as it's first move. If one of the rooks has not yet moved
 * and there are no pieces between the rook and the king, and the path is "safe", the king can castle. Castling is
 * performed by moving the king 2 spaces towards the qualifying rook, and the rook "jumping" the king to sit next
 * to the king on the opposite side it was previously. A path is considered "safe" if 1: the king is not in check
 * and 2: neither the space the king moves past nor the space the king ends up at can be reached by an opponents piece.
 */
public class CastlingTests {
    private static final String INVALID_CASTLE_PRESENT = "ChessGame validMoves contained an invalid castling move";
    private static final String VALID_CASTLE_MISSING = "ChessGame validMoves did not contain valid castle move";
    private static final String INCORRECT_BOARD = "Wrong board after castle move made";

    private static final ChessPosition WHITE_KING_POSITION = new ChessPosition(1, 5);
    private static final ChessMove WHITE_QUEENSIDE_CASTLE = new ChessMove(WHITE_KING_POSITION, new ChessPosition(1, 3), null);
    private static final ChessMove WHITE_KINGSIDE_CASTLE = new ChessMove(WHITE_KING_POSITION, new ChessPosition(1, 7), null);

    private static final ChessPosition BLACK_KING_POSITION = new ChessPosition(8, 5);
    private static final ChessMove BLACK_QUEENSIDE_CASTLE = new ChessMove(BLACK_KING_POSITION, new ChessPosition(8, 3), null);
    private static final ChessMove BLACK_KINGSIDE_CASTLE = new ChessMove(BLACK_KING_POSITION, new ChessPosition(8, 7), null);


    @Test
    @Order(0)
    @DisplayName("White Team Can Castle")
    public void castleWhite() {
        ChessGame game1 = createNewGameWithBoard("""
                | | | | |k| | | |
                | | | | | | | | |
                | | | | | | | | |
                | | | | | | | | |
                | | | | | | | | |
                | | | | | | | | |
                | | | | | | | | |
                |R| | | |K| | |R|
                """, ChessGame.TeamColor.WHITE);

        //check that with nothing in way, king can castle
        assertWhiteCanCastle(game1, true, true);

        //queen side castle works correctly
        makeMoveAndAssertBoard(game1, WHITE_QUEENSIDE_CASTLE, """
                | | | | |k| | | |
                | | | | | | | | |
                | | | | | | | | |
                | | | | | | | | |
                | | | | | | | | |
                | | | | | | | | |
                | | | | | | | | |
                | | |K|R| | | |R|
                """);

        //reset board
        ChessGame game2 = createNewGameWithBoard("""
                | | | | |k| | | |
                | | | | | | | | |
                | | | | | | | | |
                | | | | | | | | |
                | | | | | | | | |
                | | | | | | | | |
                | | | | | | | | |
                |R| | | |K| | |R|
                """, ChessGame.TeamColor.WHITE);

        //king side castle works correctly
        makeMoveAndAssertBoard(game2, WHITE_KINGSIDE_CASTLE, """
                | | | | |k| | | |
                | | | | | | | | |
                | | | | | | | | |
                | | | | | | | | |
                | | | | | | | | |
                | | | | | | | | |
                | | | | | | | | |
                |R| | | | |R|K| |
                """);
    }

    @Test
    @Order(0)
    @DisplayName("Black Team Can Castle")
    public void castleBlack() {
        ChessGame game1 = createNewGameWithBoard("""
                |r| | | |k| | |r|
                | |p| | | | | |q|
                | | | | | | | | |
                | | | | | | | | |
                | | | | | | | | |
                | | | | | | | | |
                | | | | |K| | | |
                |R| | | | | | | |
                """, ChessGame.TeamColor.BLACK);

        //check that with nothing in way, king can castle
        assertBlackCanCastle(game1, true, true);

        //queen side castle works correctly
        makeMoveAndAssertBoard(game1, BLACK_QUEENSIDE_CASTLE, """
                | | |k|r| | | |r|
                | |p| | | | | |q|
                | | | | | | | | |
                | | | | | | | | |
                | | | | | | | | |
                | | | | | | | | |
                | | | | |K| | | |
                |R| | | | | | | |
                """);


        //reset board
        ChessGame game2 = createNewGameWithBoard("""
                |r| | | |k| | |r|
                | |p| | | | | |q|
                | | | | | | | | |
                | | | | | | | | |
                | | | | | | | | |
                | | | | | | | | |
                | | | | |K| | | |
                |R| | | | | | | |
                """, ChessGame.TeamColor.BLACK);

        //king side castle works correctly
        makeMoveAndAssertBoard(game2, BLACK_KINGSIDE_CASTLE, """
                |r| | | | |r|k| |
                | |p| | | | | |q|
                | | | | | | | | |
                | | | | | | | | |
                | | | | | | | | |
                | | | | | | | | |
                | | | | |K| | | |
                |R| | | | | | | |
                """);
    }

    @Test
    @Order(1)
    @DisplayName("Cannot Castle After Moving")
    public void noCastleAfterMove() throws InvalidMoveException {
        ChessGame game = createNewGameWithBoard("""
                | | |k| | | | | |
                | | | | | | | | |
                | | | | | | | | |
                | | | | | | | | |
                | | | | | | | | |
                | | | | | | | | |
                | | | | | | | | |
                |R| | | |K| | |R|
                """, ChessGame.TeamColor.WHITE);

        //move left rook
        game.makeMove(new ChessMove(new ChessPosition(1, 1), new ChessPosition(1, 4), null));
        game.makeMove(new ChessMove(new ChessPosition(8, 3), new ChessPosition(8, 2), null));

        //move rook back to starting spot
        game.makeMove(new ChessMove(new ChessPosition(1, 4), new ChessPosition(1, 1), null));
        /*
                | |k| | | | | | |
                | | | | | | | | |
                | | | | | | | | |
                | | | | | | | | |
                | | | | | | | | |
                | | | | | | | | |
                | | | | | | | | |
                |R| | | |K| | |R|
         */


        //make sure king can't castle towards moved rook, but still can to unmoved rook
        assertWhiteCanCastle(game, false, true);

        //move king
        game.makeMove(new ChessMove(new ChessPosition(8, 2), new ChessPosition(8, 3), null));
        game.makeMove(new ChessMove(WHITE_KING_POSITION, new ChessPosition(1, 6), null));
        /*
                | | |k| | | | | |
                | | | | | | | | |
                | | | | | | | | |
                | | | | | | | | |
                | | | | | | | | |
                | | | | | | | | |
                | | | | | | | | |
                |R| | | | |K| |R|
         */

        //move king back to starting position
        game.makeMove(new ChessMove(new ChessPosition(8, 3), new ChessPosition(8, 4), null));
        game.makeMove(new ChessMove(new ChessPosition(1, 6), WHITE_KING_POSITION, null));
        /*
                | | | |k| | | | |
                | | | | | | | | |
                | | | | | | | | |
                | | | | | | | | |
                | | | | | | | | |
                | | | | | | | | |
                | | | | | | | | |
                |R| | | |K| | |R|
         */

        //make sure king can't castle anymore
        assertWhiteCanCastle(game, false, false);
    }

    @Test
    @Order(2)
    @DisplayName("Cannot Castle Through Pieces")
    public void noCastleThroughPieces() {
        ChessGame game = createNewGameWithBoard("""
                | | | | |k| | | |
                | | | | | | | | |
                | | | | | | | | |
                | | | | | | | | |
                | | | | | | | | |
                | | | | | | | | |
                | | | | | | | | |
                |R| |B| |K| |Q|R|
                """, ChessGame.TeamColor.WHITE);

        //make sure king cannot castle
        assertWhiteCanCastle(game, false, false);
    }

    @Test
    @Order(3)
    @DisplayName("Cannot Castle From Check")
    public void noCastleFromCheck() {
        ChessGame game = createNewGameWithBoard("""
                |r| | | |k| | |r|
                | | | | | | |N| |
                | | | | | | | | |
                | | | | | | | | |
                | | | | | | | | |
                | |K| | | | | | |
                | | | | | | | | |
                | | | | | | | | |
                """, ChessGame.TeamColor.BLACK);

        //make sure king cannot castle on either side
        assertBlackCanCastle(game, false, false);
    }

    @Test
    @Order(3)
    @DisplayName("Cannot Castle Through Check")
    public void noCastleThroughCheck() {
        ChessGame game = createNewGameWithBoard("""
                |r| | | |k| | |r|
                | | | | | | | | |
                | |B| | | |R| | |
                | | | | | | | | |
                | | | | | | | | |
                | |K| | | | | | |
                | | | | | | | | |
                | | | | | | | | |
                """, ChessGame.TeamColor.BLACK);

        //make sure king cannot castle on either side
        assertBlackCanCastle(game, false, false);
    }

    @Test
    @Order(3)
    @DisplayName("Cannot Castle Into Check")
    public void noCastleIntoCheck() {
        ChessGame game1 = createNewGameWithBoard("""
                | | | | |k| | | |
                | | | | | | | | |
                | | | | | | | | |
                | | |r| | | | | |
                | | | | | | | | |
                | | | | | | | | |
                | | | | | | | | |
                |R| | | |K| | |R|
                """, ChessGame.TeamColor.WHITE);

        // King cannot castle into check
        assertWhiteCanCastle(game1, false, true);


        // Try again in the other direction
        ChessGame game2 = createNewGameWithBoard("""
                | | | | |k| | | |
                | | | | | | | | |
                | | | | | | | | |
                | | | | | | |r| |
                | | | | | | | | |
                | | | | | | | | |
                | | | | | | | | |
                |R| | | |K| | |R|
                """, ChessGame.TeamColor.WHITE);

        // King cannot castle into check
        assertWhiteCanCastle(game2, true, false);
    }


    private ChessGame createNewGameWithBoard(String boardText, ChessGame.TeamColor teamTurn) {
        ChessBoard board = TestUtilities.loadBoard(boardText);
        ChessGame game = new ChessGame();
        game.setBoard(board);
        game.setTeamTurn(teamTurn);
        return game;
    }


    /**
     * Asserts that WHITE can or cannot make the queenside & kingside castle moves.
     * <br>
     * The parameter order aligns with the board when drawn from WHITE's perspective:
     * <ul>
     *     <li><b>Queenside</b> is to the <i>left</i></li>
     *     <li><b>Kingside</b> is to the <i>right</i></li>
     * </ul>
     */
    private void assertWhiteCanCastle(ChessGame game, boolean allowQueensideCastle, boolean allowKingsideCastle) {
        assertCanCastle(game, allowQueensideCastle, allowKingsideCastle, WHITE_KING_POSITION, WHITE_QUEENSIDE_CASTLE, WHITE_KINGSIDE_CASTLE);
    }
    /**
     * Asserts that BLACK can or cannot make the queenside & kingside castle moves.
     * <br>
     * The parameter order aligns with the board when drawn from WHITE's perspective:
     * <ul>
     *     <li><b>Kingside</b> is to the <i>left</i></li>
     *     <li><b>Queenside</b> is to the <i>right</i></li>
     * </ul>
     */
    private void assertBlackCanCastle(ChessGame game, boolean allowKingsideCastle, boolean allowQueensideCastle) {
        assertCanCastle(game, allowQueensideCastle, allowKingsideCastle, BLACK_KING_POSITION, BLACK_QUEENSIDE_CASTLE, BLACK_KINGSIDE_CASTLE);
    }
    private void assertCanCastle(ChessGame game, boolean allowQueensideCastle, boolean allowKingsideCastle,
                                 ChessPosition kingPosition, ChessMove queensideCastleMove, ChessMove kingsideCastleMove) {
        Assertions.assertEquals(allowQueensideCastle,
                game.validMoves(kingPosition).contains(queensideCastleMove),
                allowQueensideCastle ? VALID_CASTLE_MISSING : INVALID_CASTLE_PRESENT);
        Assertions.assertEquals(allowKingsideCastle,
                game.validMoves(kingPosition).contains(kingsideCastleMove),
                allowKingsideCastle ? VALID_CASTLE_MISSING : INVALID_CASTLE_PRESENT);
    }

    private void makeMoveAndAssertBoard(ChessGame game, ChessMove move, String boardText) {
        Assertions.assertDoesNotThrow(() -> game.makeMove(move));
        Assertions.assertEquals(TestUtilities.loadBoard(boardText), game.getBoard(), INCORRECT_BOARD);
    }

}
package websocket.messages;

import java.util.Objects;

/**
 * Represents a Message the server can send through a WebSocket
 * <p>
 * Note: You can add to this class, but you should not alter the existing
 * methods.
 */
public class ServerMessage {
    ServerMessageType serverMessageType;

    public enum ServerMessageType {
        LOAD_GAME,
        ERROR,
        NOTIFICATION
    }

    public ServerMessage(ServerMessageType type) {
        this.serverMessageType = type;
    }

    public ServerMessageType getServerMessageType() {
        return this.serverMessageType;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) {
            return true;
        }
        if (!(o instanceof ServerMessage that)) {
            return false;
        }
        return getServerMessageType() == that.getServerMessageType();
    }

    @Override
    public int hashCode() {
        return Objects.hash(getServerMessageType());
    }
}
package websocket.commands;

import java.util.Objects;

/**
 * Represents a command a user can send the server over a websocket
 * <p>
 * Note: You can add to this class, but you should not alter the existing
 * methods.
 */
public class UserGameCommand {

    private final CommandType commandType;

    private final String authToken;

    private final Integer gameID;

    public UserGameCommand(CommandType commandType, String authToken, Integer gameID) {
        this.commandType = commandType;
        this.authToken = authToken;
        this.gameID = gameID;
    }

    public enum CommandType {
        CONNECT,
        MAKE_MOVE,
        LEAVE,
        RESIGN
    }

    public CommandType getCommandType() {
        return commandType;
    }

    public String getAuthToken() {
        return authToken;
    }

    public Integer getGameID() {
        return gameID;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) {
            return true;
        }
        if (!(o instanceof UserGameCommand that)) {
            return false;
        }
        return getCommandType() == that.getCommandType() &&
                Objects.equals(getAuthToken(), that.getAuthToken()) &&
                Objects.equals(getGameID(), that.getGameID());
    }

    @Override
    public int hashCode() {
        return Objects.hash(getCommandType(), getAuthToken(), getGameID());
    }
}
package passoff.server;

import com.google.gson.GsonBuilder;

public class TestFactory {

    /*
     * Changing the return value will change how long tests will wait for the server to send messages.
     * The default for runtime is 3000 Milliseconds (3 seconds), and this will be enough for most computers. 
     * Feel free to change this as you see fit, just know increasing it can make tests take longer to run.
     * (On the flip side, if you've got a good computer feel free to decrease it)
     *
     * WHILE DEBUGGING the websocket tests, the default runtime is 300000 Milliseconds (5 minutes).
     * If you feel like you would like more time to debug, you may increase the time as you please.
     * 
     * If for some reason the tests seem to time out before reaching a point in the test you feel like they
     * should be, consider changing the last return value, instead of the default debug value.
     */
    public static Long getMessageTime() {
        boolean isDebug = java.lang.management.ManagementFactory.getRuntimeMXBean().getInputArguments()
            .toString().contains("jdwp");

        if (isDebug){
            return 300000L;
        }

        return 3000L;
    }

    public static GsonBuilder getGsonBuilder() {
        /*                  **NOT APPLICABLE TO MOST STUDENTS**
         * If you would like to change the way the web socket test cases serialize
         * or deserialize chess objects like ChessMove, you may add type adapters here.
         */
        GsonBuilder builder = new GsonBuilder();
        // builder.registerTypeAdapter(ChessMove.class, /*type adapter or json serializer */);
        return builder;
    }

}
package passoff.server;

import chess.*;
import org.junit.jupiter.api.*;
import passoff.model.*;
import passoff.websocket.*;
import server.Server;
import websocket.commands.UserGameCommand;
import websocket.messages.ServerMessage;

import java.net.URISyntaxException;
import java.util.*;
import java.util.stream.Collectors;

import static websocket.messages.ServerMessage.ServerMessageType.*;

@TestMethodOrder(MethodOrderer.OrderAnnotation.class)
public class WebSocketTests {
    private static WebsocketTestingEnvironment environment;
    private static TestServerFacade serverFacade;
    private static Server server;
    private static Long waitTime;
    private WebsocketUser white;
    private WebsocketUser black;
    private WebsocketUser observer;
    private Integer gameID;

    @AfterAll
    static void stopServer() {
        server.stop();
    }

    @BeforeAll
    public static void init() throws URISyntaxException {
        server = new Server();
        var port = Integer.toString(server.run(0));
        System.out.println("Started test HTTP server on " + port);

        serverFacade = new TestServerFacade("localhost", port);
        serverFacade.clear();
        environment = new WebsocketTestingEnvironment("localhost", port, "/ws", TestFactory.getGsonBuilder());
        waitTime = TestFactory.getMessageTime();
    }

    @BeforeEach
    public void setup() {
        //populate database with HTTP calls
        serverFacade.clear();
        white = registerUser("white", "WHITE", "white@chess.com");
        black = registerUser("black", "BLACK", "black@chess.com");
        observer = registerUser("observer", "OBSERVER", "observer@chess.com");
        gameID = createGame(white, "testGame");
        joinGame(gameID, white, ChessGame.TeamColor.WHITE);
        joinGame(gameID, black, ChessGame.TeamColor.BLACK);
    }

    @AfterEach
    public void tearDown() {
        environment.disconnectAll();
    }

    @Test
    @Order(1)
    @DisplayName("Connect 1 User")
    public void connectSingleUser() {
        connectToGame(white, gameID, true, Set.of(), Set.of(), "white player connect");
    }

    @Test
    @Order(2)
    @DisplayName("Normal Connect")
    public void connectGood() {
        setupNormalGame();    //Connects 3 Users to the game, and notifies others upon connection
    }

    @Test
    @Order(3)
    @DisplayName("Connect Bad GameID")
    public void connectBadGameID() {
        connectToGame(white, gameID + 1, false, Set.of(), Set.of(), "player connect with wrong id");
        connectToGame(observer, gameID + 1, false, Set.of(white), Set.of(), "observer connect with wrong id");
    }

    @Test
    @Order(3)
    @DisplayName("Connect Bad AuthToken")
    public void connectBadAuthToken() {
        connectToGame(new WebsocketUser("didn't register", "badAuth"), gameID, false, Set.of(), Set.of(), "connect with bad auth");
    }

    @Test
    @Order(4)
    @DisplayName("Normal Make Move")
    public void validMove() {
        setupNormalGame();

        //make a valid pawn move
        ChessMove move = new ChessMove(new ChessPosition(2, 5), new ChessPosition(3, 5), null);
        makeMove(white, gameID, move,true, false, Set.of(black, observer), Set.of(), "move made");
    }

    @Test
    @Order(5)
    @DisplayName("Make Move Bad Authtoken")
    public void makeMoveBadAuthtoken() {
        setupNormalGame();

        //make valid move command with wrong authtoken
        ChessMove move = new ChessMove(new ChessPosition(2, 6), new ChessPosition(4, 6), null);
        makeMove(new WebsocketUser(white.username(), "badAuth"), gameID, move, false, false,
                Set.of(black, observer), Set.of(), "move made with bad authtoken");
    }

    @Test
    @Order(5)
    @DisplayName("Make Invalid Move")
    public void invalidMoveBadMove() {
        setupNormalGame();

        //try to move rook through a pawn - invalid move
        ChessMove move = new ChessMove(new ChessPosition(1, 1), new ChessPosition(1, 5), null);
        makeMove(white, gameID, move, false, false, Set.of(black, observer), Set.of(), "invalid move attempted");
    }

    @Test
    @Order(5)
    @DisplayName("Make Move Wrong Turn")
    public void invalidMoveWrongTurn() {
        setupNormalGame();

        //try to move pawn out of turn - would be valid if in turn
        ChessMove move = new ChessMove(new ChessPosition(7, 5), new ChessPosition(5, 5), null);
        makeMove(black, gameID, move, false, false, Set.of(white, observer), Set.of(), "move made out of turn");
    }

    @Test
    @Order(5)
    @DisplayName("Make Move for Opponent")
    public void invalidMoveOpponent() {
        setupNormalGame();

        //attempt to have black player move white piece
        ChessMove move = new ChessMove(new ChessPosition(2, 5), new ChessPosition(4, 5), null);
        makeMove(black, gameID, move, false, false, Set.of(white, observer), Set.of(), "move made for opponent");
    }

    @Test
    @Order(5)
    @DisplayName("Make Move Observer")
    public void invalidMoveObserver() {
        setupNormalGame();

        //have observer attempt to make an otherwise valid move
        ChessMove move = new ChessMove(new ChessPosition(2, 5), new ChessPosition(4, 5), null);
        makeMove(observer, gameID, move, false, false, Set.of(white, black), Set.of(), "observer attempts move");
    }

    @Test
    @Order(5)
    @DisplayName("Make Move Game Over")
    public void invalidMoveGameOver() {
        setupNormalGame();

        //Fools mate setup
        ChessMove move = new ChessMove(new ChessPosition(2, 7), new ChessPosition(4, 7), null);
        makeMove(white, gameID, move, true, false, Set.of(black, observer), Set.of(), "first move");
        move = new ChessMove(new ChessPosition(7, 5), new ChessPosition(6, 5), null);
        makeMove(black, gameID, move, true, false, Set.of(white, observer), Set.of(), "second move");
        move = new ChessMove(new ChessPosition(2, 6), new ChessPosition(3, 6), null);
        makeMove(white, gameID, move, true, false, Set.of(black, observer), Set.of(), "third move");
        move = new ChessMove(new ChessPosition(8, 4), new ChessPosition(4, 8), null);
        makeMove(black, gameID, move, true, true, Set.of(white, observer), Set.of(), "checkmate move");
        //checkmate--attempt another move
        move = new ChessMove(new ChessPosition(2, 5), new ChessPosition(4, 5), null);
        makeMove(white, gameID, move, false, false, Set.of(black, observer), Set.of(), "invalid move");
    }

    @Test
    @Order(6)
    @DisplayName("Normal Resign")
    public void validResign() {
        setupNormalGame();
        resign(white, gameID, true, Set.of(black, observer), Set.of(), "resign");
    }

    @Test
    @Order(7)
    @DisplayName("Cannot Move After Resign")
    public void moveAfterResign() {
        setupNormalGame();
        resign(black, gameID, true, Set.of(white, observer), Set.of(), "resign");

        //attempt to make a move after other player resigns
        ChessMove move = new ChessMove(new ChessPosition(2, 5), new ChessPosition(4, 5), null);
        makeMove(white, gameID, move, false, false, Set.of(black, observer), Set.of(), "move after resign");
    }

    @Test
    @Order(7)
    @DisplayName("Observer Resign")
    public void invalidResignObserver() {
        setupNormalGame();

        //have observer try to resign - should reject
        resign(observer, gameID, false, Set.of(white, black), Set.of(), "observer resign");
    }

    @Test
    @Order(7)
    @DisplayName("Double Resign")
    public void invalidResignGameOver() {
        setupNormalGame();
        resign(black, gameID, true, Set.of(white, observer), Set.of(), "first resign");

        //attempt to resign after other player resigns
        resign(white, gameID, false, Set.of(black, observer), Set.of(), "second resign");
    }

    @Test
    @Order(8)
    @DisplayName("Leave Game")
    public void leaveGame() {
        setupNormalGame();

        //have white player leave--all other players get notified, white player should not be
        leave(white, gameID, Set.of(black, observer), Set.of(), "player/first leave");

        //observer leaves - only black player should get a notification
        leave(observer, gameID, Set.of(black), Set.of(white), "observer/second leave");
    }

    @Test
    @Order(9)
    @DisplayName("Join After Leave Game")
    public void joinAfterLeaveGame() {
        setupNormalGame();

        //have white player leave--all other players get notified, white player should not be
        leave(white, gameID, Set.of(black, observer), Set.of(), "normal leave");

        //replace white player with a different player
        WebsocketUser white2 = registerUser("white2", "WHITE", "white2@chess.com");
        joinGame(gameID, white2, ChessGame.TeamColor.WHITE);
        connectToGame(white2, gameID, true, Set.of(black, observer), Set.of(white), "connect after leave");

        //new white player can make move
        ChessMove move = new ChessMove(new ChessPosition(2, 5), new ChessPosition(3, 5), null);
        makeMove(white2, gameID, move, true, false, Set.of(black, observer), Set.of(white), "new player moves");
    }

    @Test
    @Order(10)
    @DisplayName("Multiple Concurrent Games")
    public void multipleConcurrentGames() {
        setupNormalGame();

        //setup parallel game
        WebsocketUser white2 = registerUser("white2", "WHITE", "white2@chess.com");
        WebsocketUser black2 = registerUser("black2", "BLACK", "black2@chess.com");
        WebsocketUser observer2 = registerUser("observer2", "OBSERVER", "observer2@chess.com");
        int otherGameID = createGame(white, "testGame2");
        joinGame(otherGameID, white2, ChessGame.TeamColor.WHITE);
        joinGame(otherGameID, black2, ChessGame.TeamColor.BLACK);
        connectToGame(white2, otherGameID, true, Set.of(), Set.of(white, black, observer), "connect 1 to other game");
        connectToGame(black2, otherGameID, true, Set.of(white2), Set.of(white, black, observer), "connect 2 to other game");
        connectToGame(observer2, otherGameID, true,  Set.of(white2, black2), Set.of(white, black, observer), "connect 3 to other game");

        //make move in first game - only users in first game should be notified
        ChessMove move = new ChessMove(new ChessPosition(2, 5), new ChessPosition(3, 5), null);
        makeMove(white, gameID, move, true, false, Set.of(black, observer), Set.of(white2, black2, observer2), "move from game 1");

        //resign in second game - only users in second game should be notified
        resign(white2, otherGameID, true, Set.of(black2, observer2), Set.of(white, black, observer), "resign from game 2");

        //player leave in first game - only users remaining in first game should be notified
        leave(white, gameID, Set.of(black, observer), Set.of(white2, black2, observer2), "leave from game 1");
    }

    private void setupNormalGame() {
        connectToGame(white, gameID, true, Set.of(), Set.of(), "white player connect");
        connectToGame(black, gameID, true, Set.of(white), Set.of(), "black player connect");
        connectToGame(observer, gameID, true,  Set.of(white, black), Set.of(), "observer connect");
    }

    private WebsocketUser registerUser(String name, String password, String email) {
        TestAuthResult authResult = serverFacade.register(new TestUser(name, password, email));
        assertHttpOk(authResult, "registering a new user");
        return new WebsocketUser(authResult.getUsername(), authResult.getAuthToken());
    }

    private int createGame(WebsocketUser user, String name) {
        TestCreateResult createResult = serverFacade.createGame(new TestCreateRequest(name), user.authToken());
        assertHttpOk(createResult, "creating a new game");
        return createResult.getGameID();
    }

    private void joinGame(int gameID, WebsocketUser user, ChessGame.TeamColor color) {
        TestResult result = serverFacade.joinPlayer(new TestJoinRequest(color, gameID), user.authToken());
        assertHttpOk(result, "joining a player to a game");
    }

    private void assertHttpOk(TestResult result, String context) {
        Assertions.assertEquals(200, serverFacade.getStatusCode(),
                String.format("HTTP Status code was not 200 for %s, was %d. Message: %s",
                        context, serverFacade.getStatusCode(), result.getMessage()));
    }

    private void connectToGame(WebsocketUser sender, int gameID, boolean expectSuccess,
                               Set<WebsocketUser> inGame, Set<WebsocketUser> otherClients, String description) {
        TestCommand connectCommand = new TestCommand(UserGameCommand.CommandType.CONNECT, sender.authToken(), gameID);
        Map<String, Integer> numExpectedMessages = expectedMessages(sender, 1, inGame, (expectSuccess ? 1 : 0), otherClients);
        Map<String, List<TestMessage>> actualMessages = environment.exchange(sender.username(), connectCommand, numExpectedMessages, waitTime);

        assertCommandMessages(actualMessages, expectSuccess, sender, types(LOAD_GAME), inGame, types(NOTIFICATION), otherClients, description);
    }

    private void makeMove(WebsocketUser sender, int gameID, ChessMove move, boolean expectSuccess, boolean extraNotification,
                          Set<WebsocketUser> inGame, Set<WebsocketUser> otherClients, String description) {
        TestCommand moveCommand = new TestCommand(sender.authToken(), gameID, move);
        Map<String, Integer> numExpectedMessages = expectedMessages(sender, 1, inGame, (expectSuccess ? 2 : 0), otherClients);
        Map<String, List<TestMessage>> actualMessages = environment.exchange(sender.username(), moveCommand, numExpectedMessages, waitTime);

        if(extraNotification && actualMessages.get(sender.username()).size() > 1) {
            assertCommandMessages(actualMessages, expectSuccess, sender, types(LOAD_GAME, NOTIFICATION),
                    inGame, types(LOAD_GAME, NOTIFICATION, NOTIFICATION), otherClients, description);
        }
        else {
            assertCommandMessages(actualMessages, expectSuccess, sender, types(LOAD_GAME),
                    inGame, types(LOAD_GAME, NOTIFICATION), otherClients, description);
        }
    }

    private void resign(WebsocketUser sender, int gameID, boolean expectSuccess,
                        Set<WebsocketUser> inGame, Set<WebsocketUser> otherClients, String description) {
        TestCommand resignCommand = new TestCommand(UserGameCommand.CommandType.RESIGN, sender.authToken(), gameID);
        Map<String, Integer> numExpectedMessages = expectedMessages(sender, 1, inGame, (expectSuccess ? 1 : 0), otherClients);
        Map<String, List<TestMessage>> actualMessages = environment.exchange(sender.username(), resignCommand, numExpectedMessages, waitTime);

        assertCommandMessages(actualMessages, expectSuccess, sender, types(NOTIFICATION),
                inGame, types(NOTIFICATION), otherClients, description);
    }

    private void leave(WebsocketUser sender, int gameID, Set<WebsocketUser> inGame, Set<WebsocketUser> otherClients, String description) {
        TestCommand leaveCommand = new TestCommand(UserGameCommand.CommandType.LEAVE, sender.authToken(), gameID);
        Map<String, Integer> numExpectedMessages = expectedMessages(sender, 0, inGame, 1, otherClients);
        Map<String, List<TestMessage>> actualMessages = environment.exchange(sender.username(), leaveCommand, numExpectedMessages, waitTime);

        assertCommandMessages(actualMessages, true, sender, types(), inGame, types(NOTIFICATION), otherClients, description);
    }

    private Map<String, Integer> expectedMessages(WebsocketUser sender, int senderExpected,
                                                  Set<WebsocketUser> inGame, int inGameExpected, Set<WebsocketUser> otherClients) {
        Map<String, Integer> expectedMessages = new HashMap<>();
        expectedMessages.put(sender.username(), senderExpected);
        expectedMessages.putAll(inGame.stream().collect(Collectors.toMap(WebsocketUser::username, s -> inGameExpected)));
        expectedMessages.putAll(otherClients.stream().collect(Collectors.toMap(WebsocketUser::username, s -> 0)));
        return expectedMessages;
    }

    private void assertCommandMessages(Map<String, List<TestMessage>> messages, boolean expectSuccess,
                                       WebsocketUser user, ServerMessage.ServerMessageType[] userExpectedTypes,
                                       Set<WebsocketUser> inGame, ServerMessage.ServerMessageType[] inGameExpectedTypes,
                                       Set<WebsocketUser> otherClients, String description) {
        if(!expectSuccess) {
            userExpectedTypes = new ServerMessage.ServerMessageType[]{ERROR};
            inGameExpectedTypes = new ServerMessage.ServerMessageType[0];
        }
        assertMessages(user.username(), userExpectedTypes, messages.get(user.username()), description);
        for(WebsocketUser inGameUser : inGame) {
            assertMessages(inGameUser.username(), inGameExpectedTypes, messages.get(inGameUser.username()), description);
        }
        for(WebsocketUser otherUser : otherClients) {
            assertMessages(otherUser.username(), new ServerMessage.ServerMessageType[0], messages.get(otherUser.username()), description);
        }
    }

    private void assertMessages(String username, ServerMessage.ServerMessageType[] expectedTypes, List<TestMessage> messages, String description) {
        Assertions.assertEquals(expectedTypes.length, messages.size(), "For command '%s' user '%s' expected %d messages with types %s, got %d: %s"
                .formatted(description, username, expectedTypes.length, Arrays.toString(expectedTypes), messages.size(), messages));
        Arrays.sort(expectedTypes);
        messages.sort(Comparator.comparing(TestMessage::getServerMessageType));
        try {
            for(int i = 0; i < expectedTypes.length; i++) {
                switch (expectedTypes[i]) {
                    case LOAD_GAME -> assertLoadGame(username, messages.get(i));
                    case NOTIFICATION -> assertNotification(username, messages.get(i));
                    case ERROR -> assertError(username, messages.get(i));
                }
            }
        } catch(AssertionError e) {
            Assertions.fail("\nFor command '%s' user '%s' expected message types matching %s\nGot: %s\nCause: %s"
                    .formatted(description, username, Arrays.toString(expectedTypes), messages, e.getMessage()), e);
        }
    }

    private void assertLoadGame(String username, TestMessage message) {
        Assertions.assertEquals(ServerMessage.ServerMessageType.LOAD_GAME, message.getServerMessageType(),
                "Message for %s was not a LOAD_GAME message: %s".formatted(username, message));
        Assertions.assertNotNull(message.getGame(),
                "%s's LOAD_GAME message did not contain a game (Make sure it's specifically called 'game')".formatted(username));
        Assertions.assertNull(message.getMessage(),
                "%s's LOAD_GAME message contained a message: %s".formatted(username, message.getMessage()));
        Assertions.assertNull(message.getErrorMessage(),
                "%s's LOAD_GAME message contained an error message: %s".formatted(username, message.getErrorMessage()));
    }

    private void assertNotification(String username, TestMessage message) {
        Assertions.assertEquals(ServerMessage.ServerMessageType.NOTIFICATION, message.getServerMessageType(),
                "Message for %s was not a NOTIFICATION message: %s".formatted(username, message));
        Assertions.assertNotNull(message.getMessage(),
                "%s's NOTIFICATION message did not contain a message (Make sure it's specifically called 'message')".formatted(username));
        Assertions.assertNull(message.getGame(),
                "%s's NOTIFICATION message contained a game: %s".formatted(username, message.getGame()));
        Assertions.assertNull(message.getErrorMessage(),
                "%s's NOTIFICATION message contained an error message: %s".formatted(username, message.getErrorMessage()));
    }

    private void assertError(String username, TestMessage message) {
        Assertions.assertEquals(ServerMessage.ServerMessageType.ERROR, message.getServerMessageType(),
                "Message for %s was not an ERROR message: %s".formatted(username, message));
        Assertions.assertNotNull(message.getErrorMessage(),
                "%s's ERROR message did not contain an error message (Make sure it's specifically called 'errorMessage')".formatted(username));
        Assertions.assertNull(message.getGame(),
                "%s's ERROR message contained a game: %s".formatted(username, message.getGame()));
        Assertions.assertNull(message.getMessage(),
                "%s's ERROR message contained a non-error message: %s".formatted(username, message.getMessage()));
    }

    private ServerMessage.ServerMessageType[] types(ServerMessage.ServerMessageType... types) {
        return types;
    }

    private record WebsocketUser(String username, String authToken) { }
}
package dataaccess;

/**
 * Indicates there was an error connecting to the database
 */
public class DataAccessException extends Exception{
    public DataAccessException(String message) {
        super(message);
    }
    public DataAccessException(String message, Throwable ex) {
        super(message, ex);
    }
}
package client;

import org.junit.jupiter.api.*;
import server.Server;
import model.AuthData;
import model.GameData;
import model.responses.ListGamesResponse;
import model.requests.*;

public class ServerFacadeTests {

    private static Server server;
    private static serverfacade.ServerFacade facade;

    @BeforeAll
    public static void init() {
        server = new Server();
        int port = server.run(0);
        System.out.println("Started test HTTP server on port " + port);
        facade = new serverfacade.ServerFacade("http://localhost:" + port);
    }

    @AfterAll
    public static void stopServer() {
        server.stop();
    }

    @BeforeEach
    public void clear() throws Exception {
        facade.clear();
    }

    // 
    // REGISTER
    // 
    @Test
    public void registerPositive() throws Exception {
        var auth = facade.register(new RegisterRequest("alice", "pw", "a@b.com"));
        Assertions.assertNotNull(auth);
        Assertions.assertEquals("alice", auth.username());
        Assertions.assertNotNull(auth.authToken());
    }

    @Test
    public void registerNegativeDuplicate() throws Exception {
        facade.register(new RegisterRequest("bob", "pw", "b@b.com"));
        Assertions.assertThrows(Exception.class, () ->
                facade.register(new RegisterRequest("bob", "pw", "b@b.com")));
    }


    // 
    // LOGIN
    // 
    @Test
    public void loginPositive() throws Exception {
        facade.register(new RegisterRequest("carol", "pw", "c@c.com"));
        var auth = facade.login(new LoginRequest("carol", "pw"));
        Assertions.assertEquals("carol", auth.username());
    }

    @Test
    public void loginNegativeWrongPassword() {
        Assertions.assertThrows(Exception.class, () ->
                facade.login(new LoginRequest("carol", "wrong")));
    }

    @Test
    public void loginNegativeUnknownUser() {
        Assertions.assertThrows(Exception.class, () ->
                facade.login(new LoginRequest("nosuchuser", "pw")));
    }

    // 
    // LOGOUT
    // 
    @Test
    public void logoutPositive() throws Exception {
        var auth = facade.register(new RegisterRequest("dave", "pw", "d@d.com"));
        facade.logout(auth.authToken());
        Assertions.assertThrows(Exception.class, () ->
                facade.logout(auth.authToken())); // cannot logout twice
    }

    @Test
    public void logoutNegativeInvalidToken() {
        Assertions.assertThrows(Exception.class, () ->
                facade.logout("invalid-token"));
    }

    // 
    // CLEAR
    // 
    @Test
    public void clearPositive() throws Exception {
        facade.register(new RegisterRequest("eve", "pw", "e@e.com"));
        facade.clear();
        // login should now fail
        Assertions.assertThrows(Exception.class, () ->
                facade.login(new LoginRequest("eve", "pw")));
    }

    // 
    // CREATE GAME
    // 
    @Test
    public void createGamePositive() throws Exception {
        var auth = facade.register(new RegisterRequest("frank", "pw", "f@f.com"));
        var createRes = facade.createGame(auth.authToken(), new CreateGameRequest("Game1"));
        Assertions.assertTrue(createRes.gameID() > 0);
    }

    @Test
    public void createGameNegativeInvalidAuth() {
        Assertions.assertThrows(Exception.class, () ->
                facade.createGame("badtoken", new CreateGameRequest("BadGame")));
    }

    // 
    // LIST GAMES
    // 
    @Test
    public void listGamesPositive() throws Exception {
        var auth = facade.register(new RegisterRequest("henry", "pw", "h@h.com"));
        facade.createGame(auth.authToken(), new CreateGameRequest("L1"));
        facade.createGame(auth.authToken(), new CreateGameRequest("L2"));

        ListGamesResponse resp = facade.listGames(auth.authToken());
        Assertions.assertEquals(2, resp.games().size());
    }

    @Test
    public void listGamesNegativeInvalidAuth() {
        Assertions.assertThrows(Exception.class, () ->
                facade.listGames("badtoken"));
    }

    // 
    // JOIN GAME
    // 
    @Test
    public void joinGamePositive() throws Exception {
        var auth = facade.register(new RegisterRequest("gail", "pw", "g@g.com"));
        var gid = facade.createGame(auth.authToken(), new CreateGameRequest("JoinMe"));

        facade.joinGame(auth.authToken(),
                new JoinGameRequest("WHITE", gid.gameID()));

        // second join as same color should fail
        Assertions.assertThrows(Exception.class, () ->
                facade.joinGame(auth.authToken(),
                        new JoinGameRequest("WHITE", gid.gameID())));
    }

    @Test
    public void joinGameNegativeInvalidColor() throws Exception {
        var auth = facade.register(new RegisterRequest("ivy", "pw", "i@i.com"));
        var gid = facade.createGame(auth.authToken(), new CreateGameRequest("BadColor"));

        Assertions.assertThrows(Exception.class, () ->
                facade.joinGame(auth.authToken(),
                        new JoinGameRequest("PURPLE", gid.gameID())));
    }

    @Test
    public void joinGameNegativeInvalidAuth() {
        Assertions.assertThrows(Exception.class, () ->
                facade.joinGame("badtoken",
                        new JoinGameRequest("WHITE", 1)));
    }

    @Test
    public void joinGameNegativeInvalidGame() throws Exception {
        var auth = facade.register(new RegisterRequest("kate", "pw", "k@k.com"));
        Assertions.assertThrows(Exception.class, () ->
                facade.joinGame(auth.authToken(),
                        new JoinGameRequest("WHITE", 9999)));
    }

    // 
    // GET GAME
    // 
    @Test
    public void getGamePositive() throws Exception {
        var auth = facade.register(new RegisterRequest("leo", "pw", "l@l.com"));
        var gid = facade.createGame(auth.authToken(), new CreateGameRequest("GG"));
        GameData gd = facade.getGame(gid.gameID(), auth.authToken());
        Assertions.assertEquals("GG", gd.gameName());
    }

    @Test
    public void getGameNegativeInvalidAuth() {
        Assertions.assertThrows(Exception.class, () ->
                facade.getGame(1, "invalid"));
    }
}

package ui;

public class BoardDrawer {

    // Unicode starting rows for white and black
    private static final String[] WHITE_BACK_RANK = {
            EscapeSequences.WHITE_ROOK, EscapeSequences.WHITE_KNIGHT, EscapeSequences.WHITE_BISHOP, EscapeSequences.WHITE_QUEEN,
            EscapeSequences.WHITE_KING, EscapeSequences.WHITE_BISHOP, EscapeSequences.WHITE_KNIGHT, EscapeSequences.WHITE_ROOK
    };
    private static final String[] BLACK_BACK_RANK = {
            EscapeSequences.BLACK_ROOK, EscapeSequences.BLACK_KNIGHT, EscapeSequences.BLACK_BISHOP, EscapeSequences.BLACK_QUEEN,
            EscapeSequences.BLACK_KING, EscapeSequences.BLACK_BISHOP, EscapeSequences.BLACK_KNIGHT, EscapeSequences.BLACK_ROOK
    };

    public static void drawInitialBoard(boolean blackPerspective) {
        System.out.print(EscapeSequences.ERASE_SCREEN);
        if (!blackPerspective) {
            drawWhitePerspective();
        }
        else {
            drawBlackPerspective();
        }
    }

    private static void drawWhitePerspective() {
        printColumnLetters(false);
        // row 8 down to 1
        for (int row = 8; row >= 1; row--) {
            StringBuilder line = new StringBuilder();
            line.append(EscapeSequences.SET_TEXT_COLOR_WHITE).append(row).append(" ").append(EscapeSequences.RESET_TEXT_COLOR);
            for (int col = 1; col <= 8; col++) {
                int boardRow = row;
                int boardCol = col;
                String squareContent = pieceAt(boardRow, boardCol, false);
                String bg = squareBg(boardRow, boardCol);
                line.append(bg).append(squareContent).append(EscapeSequences.RESET_BG_COLOR);
            }
            System.out.println(line);
        }
        printColumnLetters(false);
    }

    private static void drawBlackPerspective() {
        printColumnLetters(true);
        // row 1 up to 8 (so a1 top-left)
        for (int row = 1; row <= 8; row++) {
            StringBuilder line = new StringBuilder();
            line.append(EscapeSequences.SET_TEXT_COLOR_WHITE).append(9 - row).append(" ").append(EscapeSequences.RESET_TEXT_COLOR);
            for (int col = 8; col >= 1; col--) {
                int boardRow = row;
                int boardCol = col;
                String squareContent = pieceAt(boardRow, boardCol, true);
                String bg = squareBg(boardRow, boardCol);
                line.append(bg).append(squareContent).append(EscapeSequences.RESET_BG_COLOR);
            }
            System.out.println(line);
        }
        printColumnLetters(true);
    }

    private static String pieceAt(int row, int col, boolean blackPerspective) {
        // White pawns
        if (row == 2) {
            return EscapeSequences.WHITE_PAWN;
        }
        // Black pawns
        if (row == 7) {
            return EscapeSequences.BLACK_PAWN;
        }
        // White back rank
        if (row == 1) {
            return WHITE_BACK_RANK[col - 1];
        }
        // Black back rank
        if (row == 8) {
            return BLACK_BACK_RANK[col - 1];
        }
        // Empty square
        return EscapeSequences.EMPTY;
    }


    private static String squareBg(int row, int col) {
        // light squares when (row + col) % 2 == 0
        boolean light = ((row + col) % 2 == 0);
        return light ? EscapeSequences.SET_BG_COLOR_WHITE : EscapeSequences.SET_BG_COLOR_DARK_GREY;
    }

    private static void printColumnLetters(boolean reversed) {
        if (!reversed) {
            System.out.println("   a  b  c  d  e  f  g  h");
        } else {
            System.out.println("   h  g  f  e  d  c  b  a");
        }
    }
}
package ui;

/**
 * This class contains constants and functions relating to ANSI Escape Sequences that are useful in the Client display
 */
public class EscapeSequences {

    private static final String UNICODE_ESCAPE = "\u001b";
    private static final String ANSI_ESCAPE = "\033";

    public static final String ERASE_SCREEN = UNICODE_ESCAPE + "[H" + UNICODE_ESCAPE + "[2J";
    public static final String ERASE_LINE = UNICODE_ESCAPE + "[2K";

    public static final String SET_TEXT_BOLD = UNICODE_ESCAPE + "[1m";
    public static final String SET_TEXT_FAINT = UNICODE_ESCAPE + "[2m";
    public static final String RESET_TEXT_BOLD_FAINT = UNICODE_ESCAPE + "[22m";
    public static final String SET_TEXT_ITALIC = UNICODE_ESCAPE + "[3m";
    public static final String RESET_TEXT_ITALIC = UNICODE_ESCAPE + "[23m";
    public static final String SET_TEXT_UNDERLINE = UNICODE_ESCAPE + "[4m";
    public static final String RESET_TEXT_UNDERLINE = UNICODE_ESCAPE + "[24m";
    public static final String SET_TEXT_BLINKING = UNICODE_ESCAPE + "[5m";
    public static final String RESET_TEXT_BLINKING = UNICODE_ESCAPE + "[25m";

    private static final String SET_TEXT_COLOR = UNICODE_ESCAPE + "[38;5;";
    private static final String SET_BG_COLOR = UNICODE_ESCAPE + "[48;5;";

    public static final String SET_TEXT_COLOR_BLACK = SET_TEXT_COLOR + "0m";
    public static final String SET_TEXT_COLOR_LIGHT_GREY = SET_TEXT_COLOR + "242m";
    public static final String SET_TEXT_COLOR_DARK_GREY = SET_TEXT_COLOR + "235m";
    public static final String SET_TEXT_COLOR_RED = SET_TEXT_COLOR + "160m";
    public static final String SET_TEXT_COLOR_GREEN = SET_TEXT_COLOR + "46m";
    public static final String SET_TEXT_COLOR_YELLOW = SET_TEXT_COLOR + "226m";
    public static final String SET_TEXT_COLOR_BLUE = SET_TEXT_COLOR + "12m";
    public static final String SET_TEXT_COLOR_MAGENTA = SET_TEXT_COLOR + "5m";
    public static final String SET_TEXT_COLOR_WHITE = SET_TEXT_COLOR + "15m";
    public static final String RESET_TEXT_COLOR = UNICODE_ESCAPE + "[39m";

    public static final String SET_BG_COLOR_BLACK = SET_BG_COLOR + "0m";
    public static final String SET_BG_COLOR_LIGHT_GREY = SET_BG_COLOR + "242m";
    public static final String SET_BG_COLOR_DARK_GREY = SET_BG_COLOR + "235m";
    public static final String SET_BG_COLOR_RED = SET_BG_COLOR + "160m";
    public static final String SET_BG_COLOR_GREEN = SET_BG_COLOR + "46m";
    public static final String SET_BG_COLOR_DARK_GREEN = SET_BG_COLOR + "22m";
    public static final String SET_BG_COLOR_YELLOW = SET_BG_COLOR + "226m";
    public static final String SET_BG_COLOR_BLUE = SET_BG_COLOR + "12m";
    public static final String SET_BG_COLOR_MAGENTA = SET_BG_COLOR + "5m";
    public static final String SET_BG_COLOR_WHITE = SET_BG_COLOR + "15m";
    public static final String RESET_BG_COLOR = UNICODE_ESCAPE + "[49m";

    public static final String WHITE_KING = "  ";
    public static final String WHITE_QUEEN = "  ";
    public static final String WHITE_BISHOP = "  ";
    public static final String WHITE_KNIGHT = "  ";
    public static final String WHITE_ROOK = "  ";
    public static final String WHITE_PAWN = "  ";
    public static final String BLACK_KING = "  ";
    public static final String BLACK_QUEEN = "  ";
    public static final String BLACK_BISHOP = "  ";
    public static final String BLACK_KNIGHT = "  ";
    public static final String BLACK_ROOK = "  ";
    public static final String BLACK_PAWN = "  ";
    public static final String EMPTY = " \u2003 ";

    public static String moveCursorToLocation(int x, int y) { return UNICODE_ESCAPE + "[" + y + ";" + x + "H"; }
}
package serverfacade;

import com.google.gson.*;
import model.*;
import model.requests.CreateGameRequest;
import model.requests.JoinGameRequest;
import model.requests.LoginRequest;
import model.requests.RegisterRequest;
import model.responses.ListGamesResponse;
import java.net.URI;
import java.net.http.*;
import java.nio.charset.StandardCharsets;
import java.time.Duration;
import java.util.List;

import chess.ChessGame;

public class ServerFacade {

    private final String baseUrl;
    private final HttpClient client;
    private final Gson gson = new GsonBuilder().create();

    public ServerFacade(String baseUrl) {
        this.baseUrl = baseUrl.endsWith("/") ? baseUrl.substring(0, baseUrl.length()-1) : baseUrl;
        this.client = HttpClient.newBuilder()
                .connectTimeout(Duration.ofSeconds(3))
                .build();
    }

    private HttpRequest.Builder req(String path) {
        return HttpRequest.newBuilder()
                .uri(URI.create(baseUrl + path))
                .timeout(Duration.ofSeconds(5));
    }

    private String doRequest(HttpRequest request) throws Exception {
        HttpResponse<String> res = client.send(request, HttpResponse.BodyHandlers.ofString(StandardCharsets.UTF_8));
        int code = res.statusCode();
        if (code >= 200 && code < 300) {
            return res.body();
        }
        else {
            throw new Exception("Server error: " + code + " - " + res.body());
        }
    }

    // Clear DB (testing)
    public void clear() throws Exception {
        var request = req("/db").DELETE().build();
        doRequest(request);
    }

    // Register -> POST /user
    public AuthData register(RegisterRequest reqBody) throws Exception {
        String json = gson.toJson(reqBody);
        var request = req("/user")
                .header("Content-Type", "application/json")
                .POST(HttpRequest.BodyPublishers.ofString(json))
                .build();
        String body = doRequest(request);
        return gson.fromJson(body, AuthData.class);
    }

    // Login -> POST /session
    public AuthData login(LoginRequest reqBody) throws Exception {
        String json = gson.toJson(reqBody);
        var request = req("/session")
                .header("Content-Type", "application/json")
                .POST(HttpRequest.BodyPublishers.ofString(json))
                .build();
        String body = doRequest(request);
        return gson.fromJson(body, AuthData.class);
    }

    // Logout -> DELETE /session
    public void logout(String authToken) throws Exception {
        var request = req("/session")
                .header("authorization", authToken)
                .DELETE()
                .build();
        doRequest(request);
    }

    // Create Game -> POST /game
    public GameIdResponse createGame(String authToken, CreateGameRequest reqBody) throws Exception {
        String json = gson.toJson(reqBody);
        var request = req("/game")
                .header("Content-Type", "application/json")
                .header("authorization", authToken)
                .POST(HttpRequest.BodyPublishers.ofString(json))
                .build();
        String body = doRequest(request);
        return gson.fromJson(body, GameIdResponse.class);
    }

    // List Games -> GET /game
    public ListGamesResponse listGames(String authToken) throws Exception {
        var request = req("/game")
                .header("authorization", authToken)
                .GET()
                .build();
        String body = doRequest(request);
        // server returns {"games":[ ... ]}
        return gson.fromJson(body, ListGamesResponse.class);
    }

    // Join -> PUT /game
    public void joinGame(String authToken, JoinGameRequest reqBody) throws Exception {
        String json = gson.toJson(reqBody);
        var request = req("/game")
                .header("Content-Type", "application/json")
                .header("authorization", authToken)
                .PUT(HttpRequest.BodyPublishers.ofString(json))
                .build();
        doRequest(request);
    }

    // Fetch single game -> not in original spec but helpful: GET /game/{id}
    // Since server doesn't expose GET /game/{id}, we'll list and pick
    public GameData getGame(int gameID, String authToken) throws Exception {
        var list = listGames(authToken);
        for (GameData g : list.games()) {
            if (g.gameID() == gameID) {
                return g;
            }
        }
        return null;
    }

    // helper response for createGame
    public static class GameIdResponse {
        private int gameID;
        public int gameID() { return gameID; }
    }
}
import client.Client;

public class Main {
    public static void main(String[] args) {
        String serverUrl = "http://localhost:8080";
        if (args.length == 1) {
            serverUrl = args[0];
        }

        try {
            new Client(serverUrl).run();
        } catch (Throwable ex) {
            System.out.printf("Unable to start client: %s%n", ex.getMessage());
        }
    }
}
package model.responses;

public record AuthResponse(String username, String authToken) {}
package model.responses;

import model.GameData;
import java.util.List;

public record ListGamesResponse(List<GameData> games) {}
package model.responses;

public record CreateGameResponse(int gameID) {}
package model.responses;

public record ErrorResponse(String message) {}
package model.requests;

public record RegisterRequest(String username, String password, String email) {}
package model.requests;

public record JoinGameRequest(String playerColor, int gameID) {}
package model.requests;

public record CreateGameRequest(String gameName) {}
package model.requests;

public record LoginRequest(String username, String password) {}
package model;

public record UserData(String username, String password, String email) {}
package model;

public record AuthData(String authToken, String username) {}
package model;

import chess.ChessGame;

public record GameData(
        int gameID,
        String gameName,
        String whiteUsername,
        String blackUsername,
        ChessGame game
) {

    public GameData withWhite(String username) {
        return new GameData(gameID, gameName, username, blackUsername, game);
    }

    public GameData withBlack(String username) {
        return new GameData(gameID, gameName, whiteUsername, username, game);
    }

}
package client;

import com.google.gson.Gson;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import model.*;
import model.requests.CreateGameRequest;
import model.requests.JoinGameRequest;
import model.requests.LoginRequest;
import model.requests.RegisterRequest;
import model.responses.ListGamesResponse;
import serverfacade.ServerFacade;
import ui.BoardDrawer;
import ui.EscapeSequences;

import chess.ChessGame;

import java.util.*;

import static ui.EscapeSequences.*;

public class Client {

    private final ServerFacade server;
    private State state = State.SIGNEDOUT;
    private String authToken = null;
    private final Scanner scanner = new Scanner(System.in);
    private final Gson gson = new Gson();

    // map index -> gameID from last listing
    private final Map<Integer, Integer> lastListed = new HashMap<>();

    public Client(String serverUrl) {
        this.server = new ServerFacade(serverUrl);
    }

    public Client(ServerFacade server) {
        this.server = server;
    }

    public void run() {
        System.out.println( EscapeSequences.ERASE_SCREEN + " 240 Chess Client");
        System.out.print(help());

        String result = "";
        while (!"quit".equals(result)) {
            printPrompt();
            String line = scanner.nextLine().trim();
            try {
                result = eval(line);
                if (!result.isBlank()) {
                    System.out.print(result);
                }
            } catch (Exception ex) {
                System.out.println("Error: " + ex.getMessage());
            }
        }
        System.out.println("Goodbye.");
    }

    private void printPrompt() {
        System.out.print("\n>>> ");
    }

    public String eval(String input) throws Exception {
        if (input.isBlank()) {
            return "";
        }
        String[] tokens = input.split("\\s+");
        String cmd = tokens[0].toLowerCase();
        String[] params = Arrays.copyOfRange(tokens, 1, tokens.length);

        return switch (cmd) {
            case "help" -> help();
            case "quit" -> "quit";
            case "register" -> register(params);
            case "login" -> login(params);
            case "logout" -> logout();
            case "creategame" -> createGame(params);
            case "listgames" -> listGames();
            case "play" -> play(params);
            case "observe" -> observe(params);
            case "redraw" -> redraw();
            default -> "Unknown command. Type 'help'.\n";
        };
    }

    // ----- commands -----
    private String register(String... params) throws Exception {
        if (params.length != 3) {
            return "Usage: register <username> <password> <email>\n";
        }
        RegisterRequest req = new RegisterRequest(params[0], params[1], params[2]);
        AuthData auth = server.register(req);
        this.authToken = auth.authToken();
        this.state = State.SIGNEDIN;
        return "Registered and logged in as " + auth.username() + "\n";
    }

    private String login(String... params) throws Exception {
        if (params.length != 2) {
            return "Usage: login <username> <password>\n";
        }
        LoginRequest req = new LoginRequest(params[0], params[1]);
        AuthData auth = server.login(req);
        this.authToken = auth.authToken();
        this.state = State.SIGNEDIN;
        return "Logged in as " + auth.username() + "\n";
    }

    private String logout() throws Exception {
        assertSignedIn();
        server.logout(authToken);
        authToken = null;
        state = State.SIGNEDOUT;
        lastListed.clear();
        return "Logged out.\n";
    }

    private String createGame(String... params) throws Exception {
        assertSignedIn();
        if (params.length < 1) {
            return "Usage: createGame <name>\n";
        }
        String name = String.join(" ", params);
        var req = new CreateGameRequest(name);
        var res = server.createGame(authToken, req);
        return "Created game: " + name + " (id " + res.gameID() + ")\n";
    }

    private String listGames() throws Exception {
        assertSignedIn();
        ListGamesResponse resp = server.listGames(authToken);
        StringBuilder sb = new StringBuilder();
        lastListed.clear();
        int i = 1;
        for (GameData g : resp.games()) {
            lastListed.put(i, g.gameID());
            sb.append(String.format("%d) %s  [White: %s | Black: %s]%n",
                    i, g.gameName(),
                    g.whiteUsername() == null ? "-" : g.whiteUsername(),
                    g.blackUsername() == null ? "-" : g.blackUsername()));
            i++;
        }
        if (sb.isEmpty()) {
            sb.append("No games.\n");
        }
        return sb.toString();
    }

    private String play(String... params) throws Exception {
        assertSignedIn();
        if (params.length < 1) {
            return "Usage: play <list-number> (you will be prompted for color)\n";
        }
        int listNum;
        try { listNum = Integer.parseInt(params[0]); } catch (NumberFormatException e) {
            return "Invalid number. Run listGames first to see indexes.\n";
        }
        if (!lastListed.containsKey(listNum)) {
            return "Unknown game index - run listGames first.\n";
        }
        int gameId = lastListed.get(listNum);
        System.out.print("Color (white/black): ");
        String color = scanner.nextLine().trim().toUpperCase();
        if (!color.equals("WHITE") && !color.equals("BLACK")) {
            return "Invalid color. Choose 'white' or 'black'.\n";
        }
        server.joinGame(authToken, new JoinGameRequest(color, gameId));
        this.state = State.PLAYING;
        // fetch the game to get board and draw
        GameData gd = server.getGame(gameId, authToken);
        drawGame(gd, color.equals("BLACK"));
        return "Joined game " + gameId + " as " + color + "\n";
    }

    private String observe(String... params) throws Exception {
        assertSignedIn();
        if (params.length != 1) {
            return "Usage: observe <list-number>\n";
        }
        int listNum;
        try { listNum = Integer.parseInt(params[0]); } catch (NumberFormatException e) {
            return "Invalid number. Run listGames first to see indexes.\n";
        }
        if (!lastListed.containsKey(listNum)) {
            return "Unknown game index - run listGames first.\n";
        }
        int gameId = lastListed.get(listNum);
        this.state = State.OBSERVING;
        GameData gd = server.getGame(gameId, authToken);
        drawGame(gd, false); // observers see white perspective
        return "Observing game " + gameId + "\n";
    }

    private String redraw() {
        System.out.println("Redraw command only works while observing/playing via play/observe (board drawn after those actions).\n");
        return "";
    }

    // ----- helpers -----
    private void drawGame(GameData g, boolean blackPerspective) {
        if (g == null) {
            System.out.println("No game data to draw.");
            return;
        }
        ChessGame chessGame = g.game();
        if (chessGame == null) {
            // fallback: draw initial board of given perspective
            BoardDrawer.drawInitialBoard(blackPerspective);
            return;
        }
        // the BoardDrawer you provided draws initial board only; for now use drawInitialBoard
        // but if you have a drawBoard(ChessGame,boolean) you can call it here.
        BoardDrawer.drawInitialBoard(blackPerspective);
    }

    private void assertSignedIn() throws Exception {
        if (state == State.SIGNEDOUT || authToken == null) {
            throw new Exception("You must be logged in.");
        }
    }

    private String help() {
        return """
                Commands:
                - register <username> <password> <email>
                - login <username> <password>
                - logout
                - createGame <name>
                - listGames
                - play <list-number>
                - observe <list-number>
                - redraw
                - quit
                """;
    }
}
package client;

public enum State {
    SIGNEDOUT,
    SIGNEDIN,
    PLAYING,
    OBSERVING
}
//TIP To <b>Run</b> code, press <shortcut actionId="Run"/> or
// click the <icon src="AllIcons.Actions.Execute"/> icon in the gutter.
public class Main {
    public static void main(String[] args) {
        //TIP Press <shortcut actionId="ShowIntentionActions"/> with your caret at the highlighted text
        // to see how IntelliJ IDEA suggests fixing it.
        System.out.printf("Hello and welcome!");

        for (int i = 1; i <= 5; i++) {
            //TIP Press <shortcut actionId="Debug"/> to start debugging your code. We have set one <icon src="AllIcons.Debugger.Db_set_breakpoint"/> breakpoint
            // for you, but you can always add more by pressing <shortcut actionId="ToggleLineBreakpoint"/>.
            System.out.println("i = " + i);
        }
    }
}